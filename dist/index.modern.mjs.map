{"version":3,"file":"index.modern.mjs","sources":["../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/firestore-logger.ts","../src/misc/logger/logger.ts","../src/misc/dispatcher.ts","../src/misc/internal.models.ts","../src/misc/translate-from-firestore.ts","../src/misc/document-parser.ts","../src/misc/pathHelper.ts","../src/misc/translate-to-firestore.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/storage-parser.ts","../src/misc/metadata-parser.ts","../src/misc/firebase-models.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/DataProvider.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts"],"sourcesContent":["import { get, isEmpty } from 'lodash';\r\nimport { getFieldReferences, SearchObj } from './objectFlatten';\r\n\r\nexport function sortArray(\r\n  data: Array<{}>,\r\n  field: string,\r\n  dir: 'asc' | 'desc'\r\n): void {\r\n  data.sort((a: {}, b: {}) => {\r\n    const rawA = get(a, field);\r\n    const rawB = get(b, field);\r\n    const isAsc = dir === 'asc';\r\n\r\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\r\n    if (isNumberField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\r\n    if (isStringField) {\r\n      const aParsed = rawA.toLowerCase();\r\n      const bParsed = rawB.toLowerCase();\r\n      return basicSort(aParsed, bParsed, isAsc);\r\n    }\r\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\r\n    if (isDateField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    return basicSort(!!rawA, !!rawB, isAsc);\r\n  });\r\n}\r\n\r\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\r\n  if (aValue > bValue) {\r\n    return isAsc ? 1 : -1;\r\n  }\r\n  if (aValue < bValue) {\r\n    return isAsc ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport function filterArray(\r\n  data: Array<{}>,\r\n  searchFields?: { [field: string]: string | number | boolean | null }\r\n): Array<{}> {\r\n  if (!searchFields || isEmpty(searchFields)) {\r\n    return data;\r\n  }\r\n  const searchObjs: SearchObj[] = [];\r\n  Object.keys(searchFields).map((fieldName) => {\r\n    const fieldValue = searchFields[fieldName];\r\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\r\n    searchObjs.push(...getSubObjects);\r\n  });\r\n  const filtered = data.filter((row) =>\r\n    searchObjs.reduce((acc, cur) => {\r\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\r\n      return res && acc;\r\n    }, true as boolean)\r\n  );\r\n  return filtered;\r\n}\r\n\r\nexport function doesRowMatch(\r\n  row: {},\r\n  searchField: string,\r\n  searchValue: any\r\n): boolean {\r\n  const searchThis = get(row, searchField);\r\n  const bothAreFalsey = !searchThis && !searchValue;\r\n  if (bothAreFalsey) {\r\n    return true;\r\n  }\r\n  const nothingToSearch = !searchThis;\r\n  if (nothingToSearch) {\r\n    return false;\r\n  }\r\n  const isStringSearch = typeof searchValue === 'string';\r\n  if (isStringSearch) {\r\n    return searchThis\r\n      .toString()\r\n      .toLowerCase()\r\n      .includes(searchValue.toLowerCase());\r\n  }\r\n  const isBooleanOrNumber =\r\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\r\n  if (isBooleanOrNumber) {\r\n    return searchThis === searchValue;\r\n  }\r\n  const isArraySearch = Array.isArray(searchValue);\r\n  if (isArraySearch) {\r\n    return searchValue.includes(searchThis);\r\n  }\r\n  return false;\r\n}\r\n","type SearchValues = {} | number | string | boolean | null;\r\ntype SearchValue = SearchValues | SearchValue[];\r\n\r\nexport interface SearchObj {\r\n  searchField: string;\r\n  searchValue: SearchValue;\r\n}\r\nexport function getFieldReferences(\r\n  fieldName: string,\r\n  value: {} | SearchValue\r\n): SearchObj[] {\r\n  const isFalsy = !value;\r\n  const isSimple =\r\n    isFalsy ||\r\n    typeof value === 'string' ||\r\n    typeof value === 'number' ||\r\n    typeof value === 'boolean';\r\n\r\n  if (isSimple) {\r\n    return [\r\n      {\r\n        searchField: fieldName,\r\n        searchValue: value as SearchValue,\r\n      },\r\n    ];\r\n  }\r\n  const tree = {} as Record<string, SearchValue>;\r\n  tree[fieldName] = value;\r\n  return objectFlatten(tree);\r\n}\r\n\r\nexport function objectFlatten(tree: {}): SearchObj[] {\r\n  var leaves: SearchObj[] = [];\r\n  var recursivelyWalk = (obj: any, path: string | null) => {\r\n    path = path || '';\r\n    for (var key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        const objVal = obj && obj[key];\r\n        const currentPath = !!path ? path + '.' + key : key;\r\n        const isWalkable =\r\n          typeof objVal === 'object' || objVal instanceof Array;\r\n        if (isWalkable) {\r\n          recursivelyWalk(objVal, currentPath);\r\n        } else {\r\n          leaves.push({ searchField: currentPath, searchValue: objVal });\r\n        }\r\n      }\r\n    }\r\n  };\r\n  recursivelyWalk(tree, null);\r\n  return leaves;\r\n}\r\n","type LogFn = (...args: any) => void;\r\n\r\nexport const LogNoOp: LogFn = (...args: any) => null;\r\n\r\nexport class LoggerBase {\r\n  constructor(private title: string, private cacheEnabledKey: string) {}\r\n\r\n  private isEnabled() {\r\n    return !!localStorage.getItem(this.cacheEnabledKey);\r\n  }\r\n\r\n  SetEnabled(isEnabled: boolean) {\r\n    if (isEnabled) {\r\n      localStorage.setItem(this.cacheEnabledKey, 'true');\r\n    } else {\r\n      localStorage.removeItem(this.cacheEnabledKey);\r\n    }\r\n  }\r\n\r\n  public get log() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.log.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get warn() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.warn.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get error() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.error.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n}\r\n","import { RAFirebaseOptions } from 'providers/options';\r\nimport { LoggerBase, LogNoOp } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\r\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\r\n\r\nconst KEY_SINGLE = 'firecosts-single-reads';\r\n\r\nexport interface IFirestoreLogger {\r\n  logDocument: (count: number) => Function;\r\n  SetEnabled: (isEnabled: boolean) => void;\r\n  ResetCount: (shouldReset: boolean) => void;\r\n}\r\n\r\nexport function MakeFirestoreLogger(\r\n  options: RAFirebaseOptions\r\n): IFirestoreLogger {\r\n  function notEnabled() {\r\n    return !options?.lazyLoading?.enabled;\r\n  }\r\n\r\n  function incrementRead(incrementBy = 1) {\r\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\r\n    const currentCount = parseInt(currentCountRaw) || 0;\r\n    const incremented = currentCount + incrementBy;\r\n    localStorage.setItem(KEY_SINGLE, incremented + '');\r\n    return incremented;\r\n  }\r\n  function clearCache() {\r\n    localStorage.removeItem(KEY_SINGLE);\r\n  }\r\n  return {\r\n    SetEnabled(isEnabled: boolean) {\r\n      logger.SetEnabled(isEnabled);\r\n    },\r\n    ResetCount(shouldReset: boolean) {\r\n      shouldReset && clearCache();\r\n    },\r\n    logDocument(docCount: number) {\r\n      if (notEnabled()) {\r\n        return LogNoOp;\r\n      }\r\n      const count = incrementRead(docCount);\r\n      const suffix = `+${docCount} (session total=${count} documents read)`;\r\n      const boundLogFn: (...args: any) => void = logger.log.bind(\r\n        console,\r\n        suffix\r\n      );\r\n      return boundLogFn;\r\n    },\r\n  };\r\n}\r\n","import { LoggerBase } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\r\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\r\n\r\nexport const log = logger.log;\r\nexport const logError = logger.error;\r\nexport const logWarn = logger.warn;\r\n","import { log } from './logger';\r\n\r\nexport type DispatchEvent =\r\n  | 'FILE_UPLOAD_WILL_START'\r\n  | 'FILE_UPLOAD_PROGRESS'\r\n  | 'FILE_UPLOAD_PAUSED'\r\n  | 'FILE_UPLOAD_RUNNING'\r\n  | 'FILE_UPLOAD_CANCELED'\r\n  | 'FILE_UPLOAD_COMPLETE'\r\n  | 'FILE_SAVED';\r\n\r\nexport function dispatch(\r\n  eventName: DispatchEvent,\r\n  fileName: string,\r\n  data?: any\r\n): void {\r\n  const eventMonitor = document.getElementById('eventMonitor');\r\n  if (!eventMonitor) {\r\n    log(\r\n      `eventMonitor not found to dispatch event ${eventName} for ${fileName}`\r\n    );\r\n    return;\r\n  }\r\n  const eventData = { fileName, data };\r\n  let event = new CustomEvent(eventName, { detail: eventData });\r\n  eventMonitor.dispatchEvent(event);\r\n}\r\n","export const REF_INDENTIFIER = '___REF_FULLPATH_';\r\n\r\nexport interface ParsedRefDoc {\r\n  ___refpath: string;\r\n  ___refid: string;\r\n}\r\n","import { getDownloadURL, ref } from 'firebase/storage';\r\nimport { has, set } from 'lodash';\r\nimport { IFirebaseWrapper } from 'providers/database';\r\nimport { FireStoreDocumentRef } from './firebase-models';\r\nimport { REF_INDENTIFIER } from './internal.models';\r\nimport { logError } from './logger';\r\n\r\nexport interface RefDocFound {\r\n  fieldPath: string;\r\n  refDocPath: string;\r\n}\r\n\r\nexport interface FromFirestoreResult {\r\n  parsedDoc: any;\r\n  refdocs: RefDocFound[];\r\n}\r\n\r\nexport function translateDocFromFirestore(obj: any) {\r\n  const isObject = !!obj && typeof obj === 'object';\r\n  const result: FromFirestoreResult = {\r\n    parsedDoc: {},\r\n    refdocs: [],\r\n  };\r\n  if (!isObject) {\r\n    return result;\r\n  }\r\n  Object.keys(obj).map((key) => {\r\n    const value = obj[key];\r\n    obj[key] = recusivelyCheckObjectValue(value, key, result);\r\n  });\r\n  result.parsedDoc = obj;\r\n  return result;\r\n}\r\n\r\nexport function recusivelyCheckObjectValue(\r\n  input: any,\r\n  fieldPath: string,\r\n  result: FromFirestoreResult\r\n): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as any[]).map((value, index) =>\r\n      recusivelyCheckObjectValue(value, `${fieldPath}.${index}`, result)\r\n    );\r\n  }\r\n  const isDocumentReference = isInputADocReference(input);\r\n  if (isDocumentReference) {\r\n    const documentReference = input as FireStoreDocumentRef;\r\n    result.refdocs.push({\r\n      fieldPath: fieldPath,\r\n      refDocPath: documentReference.path,\r\n    });\r\n    return documentReference.id;\r\n  }\r\n  const isObject = typeof input === 'object';\r\n  if (isObject) {\r\n    Object.keys(input).map((key) => {\r\n      const value = input[key];\r\n      input[key] = recusivelyCheckObjectValue(value, key, result);\r\n    });\r\n    return input;\r\n  }\r\n  return input;\r\n}\r\n\r\nfunction isInputADocReference(input: any): boolean {\r\n  const isDocumentReference =\r\n    typeof input.id === 'string' &&\r\n    typeof input.firestore === 'object' &&\r\n    typeof input.parent === 'object' &&\r\n    typeof input.path === 'string';\r\n  return isDocumentReference;\r\n}\r\n\r\nexport function applyRefDocs(doc: any, refDocs: RefDocFound[]) {\r\n  refDocs.map((d) => {\r\n    set(doc, REF_INDENTIFIER + d.fieldPath, d.refDocPath);\r\n  });\r\n  return doc;\r\n}\r\n\r\nexport const recursivelyMapStorageUrls = async (\r\n  fireWrapper: IFirebaseWrapper,\r\n  fieldValue: any\r\n): Promise<any> => {\r\n  const isPrimitive = !fieldValue || typeof fieldValue !== 'object';\r\n  if (isPrimitive) {\r\n    return fieldValue;\r\n  }\r\n  const isFileField = has(fieldValue, 'src');\r\n  if (isFileField) {\r\n    try {\r\n      const src = await getDownloadURL(\r\n        ref(fireWrapper.storage(), fieldValue.src)\r\n      );\r\n      return {\r\n        ...fieldValue,\r\n        src,\r\n      };\r\n    } catch (error) {\r\n      logError(`Error when getting download URL`, {\r\n        error,\r\n      });\r\n      return fieldValue;\r\n    }\r\n  }\r\n  const isArray = Array.isArray(fieldValue);\r\n  if (isArray) {\r\n    return Promise.all(\r\n      (fieldValue as any[]).map(async (value, index) => {\r\n        (fieldValue as any[])[index] = await recursivelyMapStorageUrls(fireWrapper, value);\r\n      })\r\n    );\r\n  }\r\n  const isDocumentReference = isInputADocReference(fieldValue);\r\n  if (isDocumentReference) {\r\n    return fieldValue;\r\n  }\r\n  const isObject = !isArray && typeof fieldValue === 'object';\r\n  if (isObject) {\r\n    return Promise.all(\r\n      Object.keys(fieldValue).map(async (key) => {\r\n        const value = fieldValue[key];\r\n        (fieldValue as any)[key] = await recursivelyMapStorageUrls(fireWrapper, value);\r\n      })\r\n    );\r\n  }\r\n};\r\n","import {\r\n  FireStoreDocumentSnapshot,\r\n  FireStoreQueryDocumentSnapshot,\r\n} from './firebase-models';\r\nimport { logWarn } from './logger';\r\nimport * as ra from './react-admin-models';\r\nimport {\r\n  applyRefDocs,\r\n  translateDocFromFirestore,\r\n} from './translate-from-firestore';\r\n\r\nexport function parseFireStoreDocument<T extends ra.Record>(\r\n  doc: FireStoreQueryDocumentSnapshot | FireStoreDocumentSnapshot | undefined\r\n): T {\r\n  if (!doc) {\r\n    logWarn('parseFireStoreDocument: no doc', { doc });\r\n    return {} as T;\r\n  }\r\n  const data = doc.data();\r\n  const result = translateDocFromFirestore(data);\r\n  const dataWithRefs = applyRefDocs(result.parsedDoc, result.refdocs);\r\n  // React Admin requires an id field on every document,\r\n  // So we can just use the firestore document id\r\n  return { id: doc.id, ...dataWithRefs } as T;\r\n}\r\n","import path from 'path-browserify';\r\n\r\nexport function getAbsolutePath(\r\n  rootRef: undefined | string | (() => string),\r\n  relativePath: string | null\r\n): string {\r\n  if (!rootRef) {\r\n    return relativePath + '';\r\n  }\r\n  if (!relativePath) {\r\n    throw new Error(\r\n      'Resource name must be a string of length greater than 0 characters'\r\n    );\r\n  }\r\n  const rootRefValue = typeof rootRef === 'string' ? rootRef : rootRef();\r\n  const withSlashes = path.join('/', rootRefValue, '/', relativePath, '/');\r\n  const slashCount = withSlashes.split('/').length - 1;\r\n  if (slashCount % 2) {\r\n    throw new Error(`The rootRef path must point to a \"document\"\r\n    not a \"collection\"e.g. /collection/document/ or\r\n    /collection/document/collection/document/`);\r\n  }\r\n  return withSlashes.slice(1, -1);\r\n}\r\n\r\nexport function joinPaths(...args: string[]) {\r\n  return path.join(...args);\r\n}\r\n","import { REF_INDENTIFIER } from './internal.models';\r\n\r\ninterface ParsedUpload {\r\n  fieldDotsPath: string;\r\n  fieldSlashesPath: string;\r\n  rawFile: File | any;\r\n}\r\n\r\ninterface ParsedDocRef {\r\n  fieldDotsPath: string;\r\n  refPath: string;\r\n}\r\n\r\ninterface ParseResult {\r\n  parsedDoc: any;\r\n  uploads: ParsedUpload[];\r\n  refdocs: ParsedDocRef[];\r\n}\r\n\r\nexport function translateDocToFirestore(obj: any): ParseResult {\r\n  const isObject = !!obj && typeof obj === 'object';\r\n  const result: ParseResult = {\r\n    uploads: [],\r\n    refdocs: [],\r\n    parsedDoc: {},\r\n  };\r\n  if (!isObject) {\r\n    return result;\r\n  }\r\n  Object.keys(obj).map((key) => {\r\n    const value = obj[key];\r\n    recusivelyParseObjectValue(value, key, result);\r\n  });\r\n  result.parsedDoc = obj;\r\n  return result;\r\n}\r\n\r\nexport function recusivelyParseObjectValue(\r\n  input: any,\r\n  fieldPath: string,\r\n  result: ParseResult\r\n): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isRefField =\r\n    typeof fieldPath === 'string' && fieldPath.includes(REF_INDENTIFIER);\r\n  if (isRefField) {\r\n    const refDocFullPath = input as string;\r\n    result.refdocs.push({\r\n      fieldDotsPath: fieldPath,\r\n      refPath: refDocFullPath,\r\n    });\r\n    return;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as []).map((value, index) =>\r\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, result)\r\n    );\r\n  }\r\n  const isFileField = !!input && input.hasOwnProperty('rawFile');\r\n  if (isFileField) {\r\n    result.uploads.push({\r\n      fieldDotsPath: fieldPath,\r\n      fieldSlashesPath: fieldPath.split('.').join('/'),\r\n      rawFile: input.rawFile,\r\n    });\r\n    delete input.rawFile;\r\n    return;\r\n  }\r\n  Object.keys(input).map((key) => {\r\n    const value = input[key];\r\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, result);\r\n  });\r\n  return input;\r\n}\r\n","import { FirebaseApp, getApp, getApps, initializeApp } from 'firebase/app';\r\nimport {\r\n  browserLocalPersistence,\r\n  browserSessionPersistence,\r\n  getAuth,\r\n  inMemoryPersistence,\r\n  onAuthStateChanged,\r\n  Persistence,\r\n  signInWithEmailAndPassword,\r\n  signOut,\r\n} from 'firebase/auth';\r\nimport {\r\n  collection,\r\n  doc,\r\n  getFirestore,\r\n  serverTimestamp as firestoreServerTimestamp,\r\n  writeBatch,\r\n} from 'firebase/firestore';\r\nimport {\r\n  getDownloadURL,\r\n  getStorage,\r\n  ref,\r\n  uploadBytesResumable,\r\n} from 'firebase/storage';\r\nimport {\r\n  FireApp,\r\n  FireAuth,\r\n  FireAuthUserCredentials,\r\n  FireStorage,\r\n  FireStoragePutFileResult,\r\n  FireStore,\r\n  FireStoreBatch,\r\n  FireStoreCollectionRef,\r\n  FireUploadTaskSnapshot,\r\n  FireUser,\r\n} from 'misc/firebase-models';\r\nimport { log } from '../../../misc';\r\nimport { RAFirebaseOptions } from '../../options';\r\nimport { IFirebaseWrapper } from './IFirebaseWrapper';\r\n\r\nexport class FirebaseWrapper implements IFirebaseWrapper {\r\n  private readonly _app: FireApp;\r\n  private readonly _firestore: FireStore;\r\n  private readonly _storage: FireStorage;\r\n  private readonly _auth: FireAuth;\r\n  public options: RAFirebaseOptions;\r\n\r\n  constructor(inputOptions: RAFirebaseOptions | undefined, firebaseConfig: {}) {\r\n    const optionsSafe = inputOptions || {};\r\n    this.options = optionsSafe;\r\n    this._app = (window as any)['_app'] = ObtainFirebaseApp(\r\n      firebaseConfig,\r\n      optionsSafe\r\n    );\r\n    this._firestore = getFirestore(this._app);\r\n    this._storage = getStorage(this._app);\r\n    this._auth = getAuth(this._app);\r\n  }\r\n  dbGetCollection(absolutePath: string): FireStoreCollectionRef {\r\n    return collection(this._firestore, absolutePath);\r\n  }\r\n  dbCreateBatch(): FireStoreBatch {\r\n    return writeBatch(this._firestore);\r\n  }\r\n  dbMakeNewId(): string {\r\n    return doc(collection(this._firestore, 'collections')).id;\r\n  }\r\n\r\n  public OnUserLogout(callBack: (u: FireUser | null) => any) {\r\n    this._auth.onAuthStateChanged((user) => {\r\n      const isLoggedOut = !user;\r\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\r\n      if (isLoggedOut) {\r\n        callBack(user);\r\n      }\r\n    });\r\n  }\r\n  putFile(storagePath: string, rawFile: any): FireStoragePutFileResult {\r\n    const task = uploadBytesResumable(ref(this._storage, storagePath), rawFile);\r\n    const taskResult = new Promise<FireUploadTaskSnapshot>((res, rej) =>\r\n      task.then(res).catch(rej)\r\n    );\r\n\r\n    const downloadUrl = taskResult\r\n      .then((t) => getDownloadURL(t.ref))\r\n      .then((url) => url as string);\r\n\r\n    return {\r\n      task,\r\n      taskResult,\r\n      downloadUrl,\r\n    };\r\n  }\r\n  async getStorageDownloadUrl(fieldSrc: string): Promise<string> {\r\n    return getDownloadURL(ref(this._storage, fieldSrc));\r\n  }\r\n  public serverTimestamp() {\r\n    // This line doesn't work for some reason, might be firebase sdk.\r\n    return firestoreServerTimestamp();\r\n  }\r\n\r\n  async authSetPersistence(persistenceInput: 'session' | 'local' | 'none') {\r\n    let persistenceResolved: Persistence;\r\n    switch (persistenceInput) {\r\n      case 'local':\r\n        persistenceResolved = browserLocalPersistence;\r\n        break;\r\n      case 'none':\r\n        persistenceResolved = inMemoryPersistence;\r\n        break;\r\n      case 'session':\r\n      default:\r\n        persistenceResolved = browserSessionPersistence;\r\n        break;\r\n    }\r\n\r\n    log('setPersistence', { persistenceInput, persistenceResolved });\r\n\r\n    return this._auth\r\n      .setPersistence(persistenceResolved)\r\n      .catch((error) => console.error(error));\r\n  }\r\n  async authSigninEmailPassword(\r\n    email: string,\r\n    password: string\r\n  ): Promise<FireAuthUserCredentials> {\r\n    const user = await signInWithEmailAndPassword(this._auth, email, password);\r\n    return user;\r\n  }\r\n  async authSignOut(): Promise<void> {\r\n    return signOut(this._auth);\r\n  }\r\n  async authGetUserLoggedIn(): Promise<FireUser> {\r\n    return new Promise((resolve, reject) => {\r\n      const auth = this._auth;\r\n      if (auth.currentUser) return resolve(auth.currentUser);\r\n      const unsubscribe = onAuthStateChanged(this._auth, (user) => {\r\n        unsubscribe();\r\n        if (user) {\r\n          resolve(user);\r\n        } else {\r\n          reject();\r\n        }\r\n      });\r\n    });\r\n  }\r\n  public async GetUserLogin(): Promise<FireUser> {\r\n    return this.authGetUserLoggedIn();\r\n  }\r\n\r\n  /** @deprecated */\r\n  public auth(): FireAuth {\r\n    return this._auth;\r\n  }\r\n  /** @deprecated */\r\n  public storage(): FireStorage {\r\n    return this._storage;\r\n  }\r\n  /** @deprecated */\r\n  public GetApp(): FireApp {\r\n    return this._app;\r\n  }\r\n  /** @deprecated */\r\n  public db(): FireStore {\r\n    return this._firestore;\r\n  }\r\n}\r\n\r\nfunction ObtainFirebaseApp(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): FirebaseApp {\r\n  if (options.app) {\r\n    return options.app;\r\n  }\r\n  const apps = getApps();\r\n\r\n  const isInitialized = !!apps?.length;\r\n\r\n  if (isInitialized) {\r\n    return getApp();\r\n  } else {\r\n    return initializeApp(firebaseConfig);\r\n  }\r\n}\r\n","import { log, logger, logWarn, retrieveStatusTxt } from '../misc';\r\nimport { FireUser } from '../misc/firebase-models';\r\nimport {\r\n  AuthProvider as RaAuthProvider,\r\n  UserIdentity,\r\n} from '../misc/react-admin-models';\r\nimport { messageTypes } from './../misc/messageTypes';\r\nimport { IFirebaseWrapper } from './database';\r\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\r\nimport { RAFirebaseOptions } from './options';\r\n\r\nclass AuthClient {\r\n  private fireWrapper: IFirebaseWrapper;\r\n\r\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\r\n    const options = optionsInput || {};\r\n    log('Auth Client: initializing...', { firebaseConfig, options });\r\n    this.fireWrapper = new FirebaseWrapper(options, firebaseConfig);\r\n    options.persistence && this.setPersistence(options.persistence);\r\n  }\r\n\r\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\r\n    return this.fireWrapper.authSetPersistence(persistenceInput);\r\n  }\r\n\r\n  public async HandleAuthLogin(params: { username: string; password: string }) {\r\n    const { username, password } = params;\r\n\r\n    if (username && password) {\r\n      try {\r\n        const user = await this.fireWrapper.authSigninEmailPassword(\r\n          username,\r\n          password\r\n        );\r\n        log('HandleAuthLogin: user sucessfully logged in', { user });\r\n        return user;\r\n      } catch (e) {\r\n        log('HandleAuthLogin: invalid credentials', { params });\r\n        throw new Error('Login error: invalid credentials');\r\n      }\r\n    } else {\r\n      return this.getUserLogin();\r\n    }\r\n  }\r\n\r\n  public HandleAuthLogout() {\r\n    return this.fireWrapper.authSignOut();\r\n  }\r\n\r\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\r\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\r\n    const status = !!errorHttp && errorHttp.status;\r\n    const statusTxt = retrieveStatusTxt(status);\r\n    if (statusTxt === 'ok') {\r\n      log('API is actually authenticated');\r\n      return Promise.resolve();\r\n    }\r\n    logWarn('Received authentication error from API');\r\n    return Promise.reject();\r\n  }\r\n\r\n  public async HandleAuthCheck(): Promise<any> {\r\n    return this.getUserLogin();\r\n  }\r\n\r\n  public getUserLogin(): Promise<FireUser> {\r\n    return this.fireWrapper.authGetUserLoggedIn();\r\n  }\r\n\r\n  public async HandleGetPermissions() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.claims;\r\n    } catch (e) {\r\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetIdentity(): Promise<UserIdentity> {\r\n    try {\r\n      const { uid, displayName, photoURL } = await this.getUserLogin();\r\n      const identity: UserIdentity = {\r\n        id: uid,\r\n        fullName: `${displayName ?? ''}`,\r\n        avatar: `${photoURL ?? ''}`,\r\n      };\r\n      return identity;\r\n    } catch (e) {\r\n      log('HandleGetIdentity: no user is logged in', {\r\n        e,\r\n      });\r\n      return null as any;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTAuthTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.authTime;\r\n    } catch (e) {\r\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTExpirationTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.expirationTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTSignInProvider() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.signInProvider;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTIssuedAtTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.issuedAtTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTToken() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.token;\r\n    } catch (e) {\r\n      log('HandleGetJWTToken: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function AuthProvider(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): ReactAdminFirebaseAuthProvider {\r\n  VerifyAuthProviderArgs(firebaseConfig, options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  const auth = new AuthClient(firebaseConfig, options);\r\n\r\n  const provider: ReactAdminFirebaseAuthProvider = {\r\n    // React Admin Interface\r\n    login: (params) => auth.HandleAuthLogin(params),\r\n    logout: () => auth.HandleAuthLogout(),\r\n    checkAuth: () => auth.HandleAuthCheck(),\r\n    checkError: (error) => auth.HandleAuthError(error),\r\n    getPermissions: () => auth.HandleGetPermissions(),\r\n    getIdentity: () => auth.HandleGetIdentity(),\r\n    // Custom Functions\r\n    getAuthUser: () => auth.getUserLogin(),\r\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\r\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\r\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\r\n    getJWTClaims: () => auth.HandleGetPermissions(),\r\n    getJWTToken: () => auth.HandleGetJWTToken(),\r\n  };\r\n  return provider;\r\n}\r\n\r\nexport type ReactAdminFirebaseAuthProvider = RaAuthProvider & {\r\n  // Custom Functions\r\n  getAuthUser: () => Promise<FireUser>;\r\n  getJWTAuthTime: () => Promise<string | null>;\r\n  getJWTExpirationTime: () => Promise<string | null>;\r\n  getJWTSignInProvider: () => Promise<string | null>;\r\n  getJWTClaims: () => Promise<{ [key: string]: any } | null>;\r\n  getJWTToken: () => Promise<string | null>;\r\n};\r\n\r\nfunction VerifyAuthProviderArgs(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n}\r\n","// From firebase SDK\r\n\r\nimport { logError } from './logger';\r\n\r\n// tslint:disable-next-line:max-line-length\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\r\n  // Make sure any successful status is OK.\r\n  if (status >= 200 && status < 300) {\r\n    return 'ok';\r\n  }\r\n  switch (status) {\r\n    case 401: // 'unauthenticated'\r\n    case 403: // 'permission-denied'\r\n      return 'unauthenticated';\r\n\r\n    case 0: // 'internal'\r\n    case 400: // 'invalid-argument'\r\n    case 404: // 'not-found'\r\n    case 409: // 'aborted'\r\n    case 429: // 'resource-exhausted'\r\n    case 499: // 'cancelled'\r\n    case 500: // 'internal'\r\n    case 501: // 'unimplemented'\r\n    case 503: // 'unavailable'\r\n    case 504: // 'deadline-exceeded'\r\n    default:\r\n      // ignore\r\n      return 'ok';\r\n  }\r\n}\r\n\r\n// From firebase SDK\r\n// tslint:disable-next-line:max-line-length\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusCode(statusTxt: string): number {\r\n  // Make sure any successful status is OK.\r\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\r\n  const status = Array.isArray(regexResult) && regexResult[1];\r\n  if (!status) {\r\n    logError('unknown StatusCode ', { statusTxt });\r\n  }\r\n  switch (status) {\r\n    case 'unauthenticated':\r\n      return 401;\r\n    case 'permission-denied':\r\n      return 403;\r\n    case 'internal':\r\n      return 0;\r\n    case 'invalid-argument':\r\n      return 400;\r\n    case 'not-found':\r\n      return 404;\r\n    case 'aborted':\r\n      return 409;\r\n    case 'resource-exhausted':\r\n      return 429;\r\n    case 'cancelled':\r\n      return 499;\r\n    case 'internal':\r\n      return 500;\r\n    case 'unimplemented':\r\n      return 501;\r\n    case 'unavailable':\r\n      return 503;\r\n    case 'deadline-exceeded':\r\n      return 504;\r\n    default:\r\n      return 200;\r\n  }\r\n}\r\n","import { doc, getDoc, getDocs } from 'firebase/firestore';\r\nimport { FireStoreCollectionRef, FireStoreQuery } from 'misc/firebase-models';\r\nimport {\r\n  getAbsolutePath,\r\n  IFirestoreLogger,\r\n  log,\r\n  logWarn,\r\n  messageTypes,\r\n  parseFireStoreDocument,\r\n} from '../../misc';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\r\n\r\ntype IResourceItem = {} & { id: string; deleted?: boolean };\r\nexport interface IResource {\r\n  path: string;\r\n  pathAbsolute: string;\r\n  collection: FireStoreCollectionRef;\r\n  list: Array<IResourceItem>;\r\n}\r\n\r\nexport class ResourceManager {\r\n  private resources: Record<string, IResource> = {};\r\n\r\n  constructor(\r\n    private fireWrapper: IFirebaseWrapper,\r\n    private options: RAFirebaseOptions,\r\n    private flogger: IFirestoreLogger\r\n  ) {\r\n    this.fireWrapper.OnUserLogout(() => {\r\n      this.resources = {};\r\n    });\r\n  }\r\n\r\n  public async TryGetResource(\r\n    resourceName: string,\r\n    refresh?: 'REFRESH',\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    if (refresh) {\r\n      await this.RefreshResource(resourceName, collectionQuery);\r\n    }\r\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n\r\n  public GetResource(relativePath: string): IResource {\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async TryGetResourcePromise(\r\n    relativePath: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    log('resourceManager.TryGetResourcePromise', {\r\n      relativePath,\r\n      collectionQuery,\r\n    });\r\n    await this.initPath(relativePath);\r\n\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async RefreshResource(\r\n    relativePath: string,\r\n    collectionQuery: messageTypes.CollectionQueryType | undefined\r\n  ) {\r\n    if (this.options?.lazyLoading?.enabled) {\r\n      logWarn('resourceManager.RefreshResource', {\r\n        warn: 'RefreshResource is not available in lazy loading mode',\r\n      });\r\n      throw new Error(\r\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\r\n      );\r\n    }\r\n\r\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\r\n    await this.initPath(relativePath);\r\n    const resource = this.resources[relativePath];\r\n\r\n    const collectionRef = resource.collection;\r\n    const collectionOrQuery = this.applyQuery(collectionRef, collectionQuery);\r\n    const newDocs = await getDocs(collectionOrQuery);\r\n\r\n    resource.list = [];\r\n    newDocs.forEach((d) =>\r\n      resource.list.push(parseFireStoreDocument<IResourceItem>(d))\r\n    );\r\n\r\n    const count = newDocs.docs.length;\r\n    this.flogger.logDocument(count)();\r\n    log('resourceManager.RefreshResource', {\r\n      newDocs,\r\n      resource,\r\n      collectionPath: collectionRef.path,\r\n    });\r\n  }\r\n\r\n  public async GetSingleDoc(relativePath: string, docId: string): Promise<any> {\r\n    await this.initPath(relativePath);\r\n    const resource = this.GetResource(relativePath);\r\n    this.flogger.logDocument(1)();\r\n    const docSnap = await getDoc(doc(resource.collection, docId));\r\n    if (!docSnap.exists) {\r\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\r\n    }\r\n    const result = parseFireStoreDocument(docSnap);\r\n    log('resourceManager.GetSingleDoc', {\r\n      relativePath,\r\n      resource,\r\n      docId,\r\n      docSnap,\r\n      result,\r\n    });\r\n    return result;\r\n  }\r\n\r\n  private async initPath(relativePath: string): Promise<void> {\r\n    const rootRef = this.options && this.options.rootRef;\r\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\r\n    const hasBeenInited = !!this.resources[relativePath];\r\n    log('resourceManager.initPath()', {\r\n      absolutePath,\r\n      hasBeenInited,\r\n    });\r\n    if (hasBeenInited) {\r\n      log('resourceManager.initPath() has been initialized already...');\r\n      return;\r\n    }\r\n    const collection = this.fireWrapper.dbGetCollection(absolutePath);\r\n    const list: Array<IResourceItem> = [];\r\n    const resource: IResource = {\r\n      collection,\r\n      list,\r\n      path: relativePath,\r\n      pathAbsolute: absolutePath,\r\n    };\r\n    this.resources[relativePath] = resource;\r\n    log('resourceManager.initPath() setting resource...', {\r\n      resource,\r\n      allResources: this.resources,\r\n      collection: collection,\r\n      collectionPath: collection.path,\r\n    });\r\n  }\r\n\r\n  public async getUserIdentifier(): Promise<string> {\r\n    const identifier = this.options.associateUsersById\r\n      ? await this.getCurrentUserId()\r\n      : await this.getCurrentUserEmail();\r\n    return identifier;\r\n  }\r\n\r\n  private async getCurrentUserEmail() {\r\n    const user = await this.fireWrapper.authGetUserLoggedIn();\r\n    if (user) {\r\n      return user.email as string;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n  private async getCurrentUserId() {\r\n    const user = await this.fireWrapper.authGetUserLoggedIn();\r\n    if (user) {\r\n      return user.uid;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n\r\n  private applyQuery(\r\n    collection: FireStoreCollectionRef,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): FireStoreCollectionRef | FireStoreQuery {\r\n    const collRef = collectionQuery ? collectionQuery(collection) : collection;\r\n\r\n    log('resourceManager.applyQuery() ...', {\r\n      collection,\r\n      collectionQuery: (collectionQuery || '-').toString(),\r\n      collRef,\r\n    });\r\n    return collRef;\r\n  }\r\n}\r\n","import { doc } from 'firebase/firestore';\r\nimport { get, set } from 'lodash';\r\nimport {\r\n  AddCreatedByFields,\r\n  AddUpdatedByFields,\r\n  dispatch,\r\n  IFirestoreLogger,\r\n  log,\r\n  logError,\r\n  parseStoragePath,\r\n  translateDocToFirestore,\r\n} from '../../misc';\r\nimport {\r\n  TASK_CANCELED,\r\n  TASK_PAUSED,\r\n  TASK_RUNNING,\r\n} from '../../misc/firebase-models';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\r\nimport { IResource, ResourceManager } from './ResourceManager';\r\n\r\nexport class FireClient {\r\n  public rm: ResourceManager;\r\n\r\n  constructor(\r\n    public fireWrapper: IFirebaseWrapper,\r\n    public options: RAFirebaseOptions,\r\n    public flogger: IFirestoreLogger\r\n  ) {\r\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\r\n  }\r\n\r\n  public checkRemoveIdField(obj: any, docId: string) {\r\n    if (!this.options.dontAddIdFieldToDoc) {\r\n      obj.id = docId;\r\n    }\r\n  }\r\n\r\n  public transformToDb(\r\n    resourceName: string,\r\n    documentData: any,\r\n    docId: string\r\n  ): any {\r\n    if (typeof this.options.transformToDb === 'function') {\r\n      return this.options.transformToDb(resourceName, documentData, docId);\r\n    }\r\n    return documentData;\r\n  }\r\n\r\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\r\n    if (!data) {\r\n      return data;\r\n    }\r\n    const docPath = doc(r.collection, id).path;\r\n\r\n    const result = translateDocToFirestore(data);\r\n    const uploads = result.uploads;\r\n    await Promise.all(\r\n      uploads.map(async (u) => {\r\n        const storagePath = parseStoragePath(\r\n          u.rawFile,\r\n          docPath,\r\n          u.fieldDotsPath,\r\n          !!this.options.useFileNamesInStorage\r\n        );\r\n        const link = await this.saveFile(storagePath, u.rawFile);\r\n        set(data, u.fieldDotsPath + '.src', link);\r\n      })\r\n    );\r\n    return data;\r\n  }\r\n\r\n  public async addCreatedByFields(obj: any) {\r\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  public async addUpdatedByFields(obj: any) {\r\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  private async saveFile(\r\n    storagePath: string,\r\n    rawFile: any\r\n  ): Promise<string | undefined> {\r\n    log('saveFile() saving file...', { storagePath, rawFile });\r\n    try {\r\n      const { task, taskResult, downloadUrl } = this.fireWrapper.putFile(\r\n        storagePath,\r\n        rawFile\r\n      );\r\n      const { name } = rawFile;\r\n      // monitor upload status & progress\r\n      dispatch('FILE_UPLOAD_WILL_START', name);\r\n      task.on('state_changed', (snapshot) => {\r\n        const progress =\r\n          (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\r\n        log('Upload is ' + progress + '% done');\r\n        dispatch('FILE_UPLOAD_PROGRESS', name, progress);\r\n        switch (snapshot.state) {\r\n          case TASK_PAUSED:\r\n            log('Upload is paused');\r\n            dispatch('FILE_UPLOAD_PAUSED', name);\r\n            break;\r\n          case TASK_RUNNING:\r\n            log('Upload is running');\r\n            dispatch('FILE_UPLOAD_RUNNING', name);\r\n            break;\r\n          case TASK_CANCELED:\r\n            log('Upload has been canceled');\r\n            dispatch('FILE_UPLOAD_CANCELED', name);\r\n            break;\r\n          // case storage.TaskState.ERROR:\r\n          // already handled by catch\r\n          // case storage.TaskState.SUCCESS:\r\n          // already handled by then\r\n        }\r\n      });\r\n      const [getDownloadURL] = await Promise.all([downloadUrl, taskResult]);\r\n      dispatch('FILE_UPLOAD_COMPLETE', name);\r\n      dispatch('FILE_SAVED', name);\r\n      log('saveFile() saved file', {\r\n        storagePath,\r\n        taskResult,\r\n        getDownloadURL,\r\n      });\r\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\r\n    } catch (storageError) {\r\n      if (get(storageError, 'code') === 'storage/unknown') {\r\n        logError(\r\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\r\n          { storageError }\r\n        );\r\n      } else {\r\n        logError('saveFile() error saving file', {\r\n          storageError,\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { joinPaths } from './pathHelper';\r\n\r\nexport function parseStoragePath(\r\n  rawFile: File,\r\n  docPath: string,\r\n  fieldPath: string,\r\n  useFileName: boolean\r\n): string {\r\n  const fileNameBits = rawFile instanceof File ? rawFile.name.split('.') : [];\r\n\r\n  const fileExtension = !fileNameBits?.length ? '' : '.' + fileNameBits.pop();\r\n\r\n  return useFileName\r\n    ? joinPaths(docPath, fieldPath, rawFile.name)\r\n    : joinPaths(docPath, fieldPath + fileExtension);\r\n}\r\n","import { RAFirebaseOptions } from 'index';\r\nimport { IFirebaseWrapper, ResourceManager } from 'providers/database';\r\n\r\nexport async function AddCreatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | 'associateUsersById'\r\n    | 'disableMeta'\r\n    | 'renameMetaFields'\r\n    | 'metaFieldCasing'\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const createAtSelector = GetSelectorsCreateAt(options);\r\n  const createBySelector = GetSelectorsCreateBy(options);\r\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[createBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport async function AddUpdatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | 'associateUsersById'\r\n    | 'disableMeta'\r\n    | 'renameMetaFields'\r\n    | 'metaFieldCasing'\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const updateAtSelector = GetSelectorsUpdateAt(options);\r\n  const updateBySelector = GetSelectorsUpdateBy(options);\r\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[updateBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport function GetSelectorsUpdateAt(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\r\n    return options.renameMetaFields.updated_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'lastupdate';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'lastUpdate';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'last_update';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'LastUpdate';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'last-update';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsUpdateBy(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\r\n    return options.renameMetaFields.updated_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'updatedby';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'updatedBy';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'updated_by';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'UpdatedBy';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'updated-by';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateAt(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\r\n    return options.renameMetaFields.created_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'createdate';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'createDate';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'create_date';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'CreateDate';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'create-date';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateBy(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\r\n    return options.renameMetaFields.created_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'createdby';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'createdBy';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'created_by';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'CreatedBy';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'created-by';\r\n  }\r\n  return defautCase;\r\n}\r\n","import { FirebaseApp } from 'firebase/app';\r\nimport { Auth, User, UserCredential } from 'firebase/auth';\r\nimport {\r\n  CollectionReference,\r\n  DocumentData,\r\n  DocumentReference,\r\n  DocumentSnapshot,\r\n  FieldValue,\r\n  Firestore,\r\n  OrderByDirection,\r\n  Query,\r\n  QueryDocumentSnapshot,\r\n  WriteBatch,\r\n} from 'firebase/firestore';\r\nimport {\r\n  FirebaseStorage,\r\n  StorageReference,\r\n  TaskState,\r\n  UploadTask,\r\n  UploadTaskSnapshot,\r\n} from 'firebase/storage';\r\n\r\nexport type FireUser = User;\r\nexport type FireApp = FirebaseApp;\r\n\r\nexport type FireStorage = FirebaseStorage;\r\nexport type FireStorageReference = StorageReference;\r\nexport type FireUploadTaskSnapshot = UploadTaskSnapshot;\r\nexport type FireUploadTask = UploadTask;\r\nexport type FireStoragePutFileResult = {\r\n  task: FireUploadTask;\r\n  taskResult: Promise<FireUploadTaskSnapshot>;\r\n  downloadUrl: Promise<string>;\r\n};\r\n\r\nexport type FireAuth = Auth;\r\nexport type FireAuthUserCredentials = UserCredential;\r\n\r\nexport type FireStore = Firestore;\r\nexport type FireStoreBatch = WriteBatch;\r\nexport type FireStoreTimeStamp = FieldValue;\r\nexport type FireStoreDocumentRef = DocumentReference;\r\nexport type FireStoreDocumentSnapshot = DocumentSnapshot<DocumentData>;\r\nexport type FireStoreCollectionRef = CollectionReference;\r\nexport type FireStoreQueryDocumentSnapshot = QueryDocumentSnapshot;\r\nexport type FireStoreQuery = Query;\r\nexport type FireStoreQueryOrder = OrderByDirection;\r\n\r\nexport const TASK_PAUSED = 'paused' as TaskState;\r\nexport const TASK_RUNNING = 'running' as TaskState;\r\nexport const TASK_CANCELED = 'cancelled' as TaskState;\r\n","import { Buffer } from 'buffer';\r\nimport {\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  limit,\r\n  query,\r\n  QueryConstraint,\r\n  startAfter,\r\n  startAt,\r\n} from 'firebase/firestore';\r\nimport { ref } from 'firebase/storage';\r\nimport {\r\n  FireStoreCollectionRef,\r\n  FireStoreDocumentSnapshot,\r\n  FireStoreQuery,\r\n} from 'misc/firebase-models';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\n\r\nexport function setQueryCursor(\r\n  document: FireStoreDocumentSnapshot,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string\r\n) {\r\n  const key = Buffer.from(JSON.stringify({ ...params, resourceName })).toString('base64');\r\n  localStorage.setItem(key, document.id);\r\n\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (!localCursorKeys) {\r\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\r\n  } else {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    const newCursors = cursors.concat(key);\r\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\r\n  }\r\n}\r\n\r\nexport async function getQueryCursor(\r\n  collection: FireStoreCollectionRef,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<FireStoreDocumentSnapshot | false> {\r\n  const key = Buffer.from(JSON.stringify({ ...params, resourceName }), 'base64').toString();\r\n  const docId = localStorage.getItem(key);\r\n  if (!docId) {\r\n    return false;\r\n  }\r\n\r\n  const docSnapshot = await getDoc(doc(collection, docId));\r\n  flogger.logDocument(1)();\r\n  if (docSnapshot.exists()) {\r\n    return docSnapshot;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function clearQueryCursors(resourceName: string) {\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (localCursorKeys) {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\r\n    localStorage.removeItem(allCursorsKey);\r\n  }\r\n}\r\n\r\nexport async function findLastQueryCursor(\r\n  collection: FireStoreCollectionRef,\r\n  queryConstraints: QueryConstraint[],\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n) {\r\n  const { page, perPage } = params.pagination;\r\n\r\n  let lastQueryCursor: FireStoreDocumentSnapshot | false = false;\r\n  let currentPage = page - 1;\r\n\r\n  const currentPageParams = {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n    },\r\n  };\r\n  while (!lastQueryCursor && currentPage > 1) {\r\n    currentPage--;\r\n    currentPageParams.pagination.page = currentPage;\r\n    console.log('getting query cursor currentPage=', currentPage);\r\n    lastQueryCursor = await getQueryCursor(\r\n      collection,\r\n      currentPageParams,\r\n      resourceName,\r\n      flogger\r\n    );\r\n  }\r\n  const pageLimit = (page - currentPage) * perPage;\r\n  const isFirst = currentPage === 1;\r\n\r\n  function getQuery() {\r\n    if (isFirst) {\r\n      return query(collection, ...[...queryConstraints, limit(pageLimit)]);\r\n    } else {\r\n      return query(\r\n        collection,\r\n        ...[...queryConstraints, startAfter(lastQueryCursor), limit(pageLimit)]\r\n      );\r\n    }\r\n  }\r\n\r\n  const newQuery = getQuery();\r\n  const snapshots = await getDocs(newQuery);\r\n  const docsLength = snapshots.docs.length;\r\n  flogger.logDocument(docsLength)();\r\n  const lastDocIndex = docsLength - 1;\r\n  const lastDocRef = snapshots.docs[lastDocIndex];\r\n  return lastDocRef;\r\n}\r\n","import {\r\n  getDocs,\r\n  limit,\r\n  orderBy,\r\n  query,\r\n  QueryConstraint,\r\n  startAfter,\r\n  where,\r\n} from 'firebase/firestore';\r\nimport {\r\n  FireStoreCollectionRef,\r\n  FireStoreQuery,\r\n  FireStoreQueryOrder,\r\n} from 'misc/firebase-models';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\r\n\r\ninterface ParamsToQueryOptions {\r\n  filters?: boolean;\r\n  sort?: boolean;\r\n  pagination?: boolean;\r\n}\r\n\r\ninterface QueryPair {\r\n  noPagination: FireStoreQuery;\r\n  withPagination: FireStoreQuery;\r\n}\r\n\r\nconst defaultParamsToQueryOptions = {\r\n  filters: true,\r\n  sort: true,\r\n  pagination: true,\r\n};\r\n\r\nexport async function paramsToQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(\r\n  collection: FireStoreCollectionRef,\r\n  params: TParams,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger,\r\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\r\n): Promise<QueryPair> {\r\n  const filterConstraints = options.filters\r\n    ? getFiltersConstraints(params.filter)\r\n    : [];\r\n\r\n  const sortConstraints = options.sort ? getSortConstraints(params.sort) : [];\r\n\r\n  const paginationConstraints = options.pagination\r\n    ? await getPaginationConstraints(\r\n        collection,\r\n        [...filterConstraints, ...sortConstraints],\r\n        params,\r\n        resourceName,\r\n        flogger\r\n      )\r\n    : [];\r\n\r\n  return {\r\n    noPagination: query(\r\n      collection,\r\n      ...[...filterConstraints, ...sortConstraints]\r\n    ),\r\n    withPagination: query(\r\n      collection,\r\n      ...[...filterConstraints, ...sortConstraints, ...paginationConstraints]\r\n    ),\r\n  };\r\n}\r\n\r\nexport function getFiltersConstraints(filters: {\r\n  [fieldName: string]: any;\r\n}): QueryConstraint[] {\r\n  return Object.entries(filters).flatMap(([fieldName, fieldValue]) => {\r\n    if (Array.isArray(fieldValue)) {\r\n      return [where(fieldName, 'array-contains-any', fieldValue)];\r\n    } else if (typeof fieldValue === 'object') {\r\n      // if fieldValue is an object, { a: 'value', b: 'value' }\r\n      // then we want to return a query for each key in the object\r\n      return Object.entries(fieldValue).map(([key, value]) => {\r\n        return where(fieldName + '.' + key, '==', value);\r\n      });\r\n    } else if (Object.keys(filters).length === 1 && isNaN(fieldValue) && typeof fieldValue !== 'string') {\r\n      return [\r\n        where(fieldName, '>=', fieldValue),\r\n        where(fieldName, '<', fieldValue + 'z'),\r\n      ];\r\n    } else {\r\n      return [where(fieldName, '==', fieldValue)];\r\n    }\r\n  });\r\n}\r\n\r\nexport function getSortConstraints(sort: {\r\n  field: string;\r\n  order: string;\r\n}): QueryConstraint[] {\r\n  if (sort != null && sort.field !== 'id') {\r\n    const { field, order } = sort;\r\n    const parsedOrder = order.toLocaleLowerCase() as FireStoreQueryOrder;\r\n    return [orderBy(field, parsedOrder)];\r\n  }\r\n  return [];\r\n}\r\n\r\nasync function getPaginationConstraints<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(\r\n  collectionRef: FireStoreCollectionRef,\r\n  queryConstraints: QueryConstraint[],\r\n  params: TParams,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<QueryConstraint[]> {\r\n  const { page, perPage } = params.pagination;\r\n\r\n  if (page === 1) {\r\n    return [limit(perPage)];\r\n  } else {\r\n    let queryCursor = await getQueryCursor(\r\n      collectionRef,\r\n      params,\r\n      resourceName,\r\n      flogger\r\n    );\r\n    if (!queryCursor) {\r\n      queryCursor = await findLastQueryCursor(\r\n        collectionRef,\r\n        queryConstraints,\r\n        params,\r\n        resourceName,\r\n        flogger\r\n      );\r\n    }\r\n    return [startAfter(queryCursor), limit(perPage)];\r\n  }\r\n}\r\n\r\nexport function getFullParamsForQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\r\n  return {\r\n    ...reactAdminParams,\r\n    filter: softdeleteEnabled\r\n      ? {\r\n          deleted: false,\r\n          ...reactAdminParams.filter,\r\n        }\r\n      : reactAdminParams.filter,\r\n  };\r\n}\r\n\r\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\r\n  params: TParams\r\n): TParams {\r\n  return {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n      page: params.pagination.page + 1,\r\n    },\r\n  };\r\n}\r\n","import { getCountFromServer, getDocs } from 'firebase/firestore';\r\nimport {\r\n  log,\r\n  messageTypes,\r\n  parseFireStoreDocument,\r\n  recursivelyMapStorageUrls,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient, IResource, ResourceManager } from '../database';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport {\r\n  getFullParamsForQuery,\r\n  getNextPageParams,\r\n  paramsToQuery,\r\n} from './paramsToQuery';\r\nimport { setQueryCursor } from './queryCursors';\r\n\r\nexport class FirebaseLazyLoadingClient {\r\n  constructor(\r\n    private readonly options: RAFirebaseOptions,\r\n    private readonly rm: ResourceManager,\r\n    private client: FireClient\r\n  ) {}\r\n\r\n  public async apiGetList<T extends ra.Record>(\r\n    resourceName: string,\r\n    reactAdminParams: ra.GetListParams\r\n  ): Promise<ra.GetListResult<T>> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    const params = getFullParamsForQuery(\r\n      reactAdminParams,\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    log('apiGetListLazy', { resourceName, params });\r\n\r\n    const { noPagination, withPagination } = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await getDocs(withPagination);\r\n\r\n    const resultsCount = snapshots.docs.length;\r\n    if (!resultsCount) {\r\n      log('apiGetListLazy', {\r\n        message: 'There are not records for given query',\r\n      });\r\n      return { data: [], total: 0 };\r\n    }\r\n    this.client.flogger.logDocument(resultsCount)();\r\n\r\n    // tslint:disable-next-line\r\n    const data = snapshots.docs.map((d) => parseFireStoreDocument<T>(d));\r\n\r\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\r\n    // After fetching documents save queryCursor for next page\r\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\r\n    // Hardcoded to allow next pages, as we don't have total number of items\r\n\r\n    let total = await getCountFromServer(noPagination);\r\n\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetListLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total: total.data().count,\r\n      };\r\n    }\r\n\r\n    log('apiGetListLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n\r\n    return { data, total: total.data().count };\r\n  }\r\n\r\n  public async apiGetManyReference(\r\n    resourceName: string,\r\n    reactAdminParams: messageTypes.IParamsGetManyReference\r\n  ): Promise<messageTypes.IResponseGetManyReference> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    log('apiGetManyReferenceLazy', {\r\n      resourceName,\r\n      resource: r,\r\n      reactAdminParams,\r\n    });\r\n    const filterWithTarget = {\r\n      ...reactAdminParams.filter,\r\n      [reactAdminParams.target]: reactAdminParams.id,\r\n    };\r\n    const params = getFullParamsForQuery(\r\n      {\r\n        ...reactAdminParams,\r\n        filter: filterWithTarget,\r\n      },\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    const { withPagination } = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await getDocs(withPagination);\r\n    const resultsCount = snapshots.docs.length;\r\n    this.client.flogger.logDocument(resultsCount)();\r\n    const data = snapshots.docs.map(parseFireStoreDocument);\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetManyReferenceLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total: data.length,\r\n      };\r\n    }\r\n\r\n    log('apiGetManyReferenceLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n    return { data, total: data.length };\r\n  }\r\n\r\n  private async tryGetResource(\r\n    resourceName: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n}\r\n","import {\r\n  getAbsolutePath,\r\n  log,\r\n  logError,\r\n  logger,\r\n  MakeFirestoreLogger,\r\n  retrieveStatusCode,\r\n} from '../misc';\r\nimport { FireApp } from '../misc/firebase-models';\r\nimport * as ra from '../misc/react-admin-models';\r\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from './commands';\r\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\r\nimport { FireClient } from './database/FireClient';\r\nimport { RAFirebaseOptions } from './options';\r\nimport { GetList, GetMany, GetManyReference, GetOne } from './queries';\r\n\r\nexport interface IDataProvider extends ra.DataProvider {\r\n  app: FireApp;\r\n}\r\n\r\nexport function DataProvider(\r\n  firebaseConfig: {},\r\n  optionsInput?: RAFirebaseOptions\r\n): IDataProvider {\r\n  const options = optionsInput || {};\r\n  verifyDataProviderArgs(firebaseConfig, options);\r\n\r\n  const flogger = MakeFirestoreLogger(options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\r\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\r\n  log('Creating FirebaseDataProvider', {\r\n    firebaseConfig,\r\n    options,\r\n  });\r\n\r\n  const fireWrapper = new FirebaseWrapper(optionsInput, firebaseConfig);\r\n\r\n  async function run<T>(cb: () => Promise<T>) {\r\n    let res: any;\r\n    try {\r\n      res = await cb();\r\n      return res;\r\n    } catch (error) {\r\n      const errorMsg = ((error as any) || '').toString();\r\n      const code = retrieveStatusCode(errorMsg);\r\n      const errorObj = { status: code, message: errorMsg, json: res };\r\n      logError('DataProvider:', error, { errorMsg, code, errorObj });\r\n      throw errorObj;\r\n    }\r\n  }\r\n  const client = new FireClient(fireWrapper, options, flogger);\r\n\r\n  const newProviderApi: IDataProvider = {\r\n    app: fireWrapper.GetApp(),\r\n    getList<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetListParams\r\n    ): Promise<ra.GetListResult<RecordType>> {\r\n      return run(() => GetList<RecordType>(resource, params, client));\r\n    },\r\n    getOne<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetOneParams\r\n    ): Promise<ra.GetOneResult<RecordType>> {\r\n      return run(() => GetOne<RecordType>(resource, params, client));\r\n    },\r\n    getMany<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyParams\r\n    ): Promise<ra.GetManyResult<RecordType>> {\r\n      return run(() => GetMany<RecordType>(resource, params, client));\r\n    },\r\n    getManyReference<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyReferenceParams\r\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\r\n      return run(() => GetManyReference<RecordType>(resource, params, client));\r\n    },\r\n    update<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.UpdateParams\r\n    ): Promise<ra.UpdateResult<RecordType>> {\r\n      return run(() => Update<RecordType>(resource, params, client));\r\n    },\r\n    updateMany(\r\n      resource: string,\r\n      params: ra.UpdateManyParams\r\n    ): Promise<ra.UpdateManyResult> {\r\n      return run(() => UpdateMany(resource, params, client));\r\n    },\r\n    create<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.CreateParams\r\n    ): Promise<ra.CreateResult<RecordType>> {\r\n      return run(() => Create<RecordType>(resource, params, client));\r\n    },\r\n    delete<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.DeleteParams\r\n    ): Promise<ra.DeleteResult<RecordType>> {\r\n      return run(() => Delete(resource, params, client));\r\n    },\r\n    deleteMany(\r\n      resource: string,\r\n      params: ra.DeleteManyParams\r\n    ): Promise<ra.DeleteManyResult> {\r\n      return run(() => DeleteMany(resource, params, client));\r\n    },\r\n  };\r\n\r\n  return newProviderApi;\r\n}\r\n\r\nfunction verifyDataProviderArgs(\r\n  firebaseConfig: {},\r\n  options?: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n  if (options && options.rootRef) {\r\n    // Will throw error if rootRef doesn't point to a document\r\n    getAbsolutePath(options.rootRef, 'test');\r\n  }\r\n}\r\n","import {\r\n  filterArray,\r\n  log,\r\n  recursivelyMapStorageUrls,\r\n  sortArray,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\r\n\r\nexport async function GetList<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetListParams,\r\n  client: FireClient\r\n): Promise<ra.GetListResult<T>> {\r\n  log('GetList', { resourceName, params });\r\n  const { rm, fireWrapper, options } = client;\r\n\r\n  if (options?.lazyLoading?.enabled) {\r\n    const lazyClient = new FirebaseLazyLoadingClient(options, rm, client);\r\n    return lazyClient.apiGetList<T>(resourceName, params);\r\n  }\r\n\r\n  const filterSafe = params.filter || {};\r\n\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  delete filterSafe.collectionQuery;\r\n\r\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\r\n  const data = r.list;\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === 'ASC') {\r\n      sortArray(data, field, 'asc');\r\n    } else {\r\n      sortArray(data, field, 'desc');\r\n    }\r\n  }\r\n  let softDeleted = data;\r\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\r\n    softDeleted = data.filter((doc) => !doc.deleted);\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\r\n  const total = filteredData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const fetchedData = await Promise.all(\r\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return {\r\n      data: fetchedData,\r\n      total,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: dataPage,\r\n    total,\r\n  };\r\n}\r\n","import { log, translateDocFromFirestore } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetOne<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetOneParams,\r\n  client: FireClient\r\n): Promise<ra.GetOneResult<T>> {\r\n  log('GetOne', { resourceName, params });\r\n  const { rm } = client;\r\n  try {\r\n    const id = params.id + '';\r\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\r\n    client.flogger.logDocument(1)();\r\n    return { data: dataSingle as T };\r\n  } catch (error) {\r\n    throw new Error(\r\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\r\n    );\r\n  }\r\n}\r\n","import { doc, getDoc } from 'firebase/firestore';\r\nimport { log, recursivelyMapStorageUrls } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetMany<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  const ids = params.ids;\r\n  log('GetMany', { resourceName, resource: r, params, ids });\r\n  const matchDocSnaps = await Promise.all(\r\n    ids.map((idObj) => {\r\n      if (typeof idObj === 'string') {\r\n        return getDoc(doc(r.collection, idObj));\r\n      }\r\n      // Will get and resolve reference documents into the current doc\r\n      return getDoc(doc(r.collection, (idObj as any)['___refid']));\r\n    })\r\n  );\r\n  client.flogger.logDocument(ids.length)();\r\n  const matches = matchDocSnaps.map(\r\n    (snap) => ({ ...snap.data(), id: snap.id } as T)\r\n  );\r\n  const permittedData = options.softDelete\r\n    ? matches.filter((row) => !row['deleted'])\r\n    : matches;\r\n  if (options.relativeFilePaths) {\r\n    const data = await Promise.all(\r\n      permittedData.map((d) => recursivelyMapStorageUrls(fireWrapper, d))\r\n    );\r\n    return {\r\n      data,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: permittedData,\r\n  };\r\n}\r\n","import {\r\n  filterArray,\r\n  log,\r\n  recursivelyMapStorageUrls,\r\n  sortArray,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetManyReference<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyReferenceParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyReferenceResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  log('GetManyReference', { resourceName, params });\r\n  const filterSafe = params.filter || {};\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\r\n  delete filterSafe.collectionQuery;\r\n  log('apiGetManyReference', { resourceName, resource: r, params });\r\n  const data = r.list;\r\n  const targetField = params.target;\r\n  const targetValue = params.id;\r\n  let softDeleted = data;\r\n  if (options.softDelete) {\r\n    softDeleted = data.filter((doc) => !doc['deleted']);\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const targetIdFilter: Record<string, ra.Identifier> = {};\r\n  targetIdFilter[targetField] = targetValue;\r\n  const permittedData = filterArray(filteredData, targetIdFilter);\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === 'ASC') {\r\n      sortArray(permittedData, field, 'asc');\r\n    } else {\r\n      sortArray(permittedData, field, 'desc');\r\n    }\r\n  }\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\r\n  const total = permittedData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const fetchedData = await Promise.all(\r\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return { data: fetchedData, total };\r\n  }\r\n\r\n  return { data: dataPage, total };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function Update<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.UpdateParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateResult<T>> {\r\n  const { rm } = client;\r\n  log('Update', { resourceName, params });\r\n  const id = params.id + '';\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('Update', { resourceName, resource: r, params });\r\n  const data = await client.parseDataAndUpload(r, id, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, id);\r\n  await client.addUpdatedByFields(docObj);\r\n  const docObjTransformed = client.transformToDb(resourceName, docObj, id);\r\n  await updateDoc(doc(r.collection, id), docObjTransformed);\r\n  return {\r\n    data: {\r\n      ...data,\r\n      id: id,\r\n    },\r\n  };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function UpdateMany(\r\n  resourceName: string,\r\n  params: ra.UpdateManyParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateManyResult> {\r\n  const { rm } = client;\r\n  log('UpdateMany', { resourceName, params });\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('UpdateMany', { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async (id) => {\r\n      const idStr = id + '';\r\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\r\n      const docObj = { ...data };\r\n      client.checkRemoveIdField(docObj, idStr);\r\n      await client.addUpdatedByFields(docObj);\r\n      const docObjTransformed = client.transformToDb(\r\n        resourceName,\r\n        docObj,\r\n        idStr\r\n      );\r\n      await updateDoc(doc(r.collection, idStr), docObjTransformed);\r\n      return {\r\n        ...data,\r\n        id: idStr,\r\n      };\r\n    })\r\n  );\r\n  return {\r\n    data: returnData,\r\n  };\r\n}\r\n","import { doc, getDoc, setDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function Create<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.CreateParams,\r\n  client: FireClient\r\n): Promise<ra.CreateResult<T>> {\r\n  const { rm, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('Create', { resourceName, resource: r, params });\r\n  const hasOverridenDocId = params.data && params.data.id;\r\n  log('Create', { hasOverridenDocId });\r\n  if (hasOverridenDocId) {\r\n    const overridenId = params.data.id;\r\n    const exists = (await getDoc(doc(r.collection, overridenId))).exists();\r\n    if (exists) {\r\n      throw new Error(\r\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\r\n      );\r\n    }\r\n\r\n    const createData = await client.parseDataAndUpload(\r\n      r,\r\n      overridenId,\r\n      params.data\r\n    );\r\n    if (!overridenId) {\r\n      throw new Error('id must be a valid string');\r\n    }\r\n    const createDocObj = { ...createData };\r\n    client.checkRemoveIdField(createDocObj, overridenId);\r\n    await client.addCreatedByFields(createDocObj);\r\n    await client.addUpdatedByFields(createDocObj);\r\n    const createDocObjTransformed = client.transformToDb(\r\n      resourceName,\r\n      createDocObj,\r\n      overridenId\r\n    );\r\n    log('Create', { docObj: createDocObj });\r\n    await setDoc(doc(r.collection, overridenId), createDocObjTransformed, {\r\n      merge: false,\r\n    });\r\n    return {\r\n      data: {\r\n        ...createDocObjTransformed,\r\n        id: overridenId,\r\n      },\r\n    };\r\n  }\r\n  const newId = fireWrapper.dbMakeNewId();\r\n  const data = await client.parseDataAndUpload(r, newId, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, newId);\r\n  await client.addCreatedByFields(docObj);\r\n  await client.addUpdatedByFields(docObj);\r\n  const docObjTransformed = client.transformToDb(resourceName, docObj, newId);\r\n  await setDoc(doc(r.collection, newId), docObjTransformed, { merge: false });\r\n  return {\r\n    data: {\r\n      ...docObjTransformed,\r\n      id: newId,\r\n    },\r\n  };\r\n}\r\n","import { deleteDoc, doc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\nimport { DeleteSoft } from './Delete.Soft';\r\n\r\nexport async function Delete<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm, options } = client;\r\n  if (options.softDelete) {\r\n    return DeleteSoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('apiDelete', { resourceName, resource: r, params });\r\n  try {\r\n    const id = params.id + '';\r\n\r\n    await deleteDoc(doc(r.collection, id));\r\n  } catch (error) {\r\n    throw new Error(error as any);\r\n  }\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log, logError } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function DeleteSoft<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm } = client;\r\n  const id = params.id + '';\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteSoft', { resourceName, resource: r, params });\r\n  const docObj = { deleted: true };\r\n  await client.addUpdatedByFields(docObj);\r\n\r\n  updateDoc(doc(r.collection, id), docObj).catch((error) => {\r\n    logError('DeleteSoft error', { error });\r\n  });\r\n\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { doc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\nimport { DeleteManySoft } from './DeleteMany.Soft';\r\n\r\nexport async function DeleteMany(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { options, rm, fireWrapper } = client;\r\n  if (options.softDelete) {\r\n    return DeleteManySoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteMany', { resourceName, resource: r, params });\r\n  const returnData: ra.Identifier[] = [];\r\n  const batch = fireWrapper.dbCreateBatch();\r\n  for (const id of params.ids) {\r\n    const idStr = id + '';\r\n    const docToDelete = doc(r.collection, idStr);\r\n    batch.delete(docToDelete);\r\n    returnData.push(id);\r\n  }\r\n\r\n  try {\r\n    await batch.commit();\r\n  } catch (error) {\r\n    throw new Error(error as any);\r\n  }\r\n  return { data: returnData };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log, logError } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function DeleteManySoft(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { rm } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteManySoft', { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async (id) => {\r\n      const idStr = id + '';\r\n      const docObj = { deleted: true };\r\n      await client.addUpdatedByFields(docObj);\r\n      updateDoc(doc(r.collection, idStr), docObj).catch((error) => {\r\n        logError('apiSoftDeleteMany error', { error });\r\n      });\r\n      return idStr;\r\n    })\r\n  );\r\n  return {\r\n    data: returnData,\r\n  };\r\n}\r\n"],"names":["sortArray","data","field","dir","sort","a","b","rawA","get","rawB","isAsc","Number","isFinite","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","value","searchField","searchValue","tree","leaves","recursivelyWalk","obj","path","key","hasOwnProperty","objVal","currentPath","Array","push","objectFlatten","getFieldReferences","filter","row","reduce","acc","cur","res","searchThis","toString","includes","isArray","doesRowMatch","LogNoOp","args","LoggerBase","title","cacheEnabledKey","constructor","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","log","console","bind","warn","error","logger","KEY_SINGLE","logError","logWarn","dispatch","eventName","fileName","eventMonitor","document","getElementById","event","CustomEvent","detail","dispatchEvent","REF_INDENTIFIER","translateDocFromFirestore","result","parsedDoc","refdocs","recusivelyCheckObjectValue","input","fieldPath","toDate","index","isInputADocReference","documentReference","refDocPath","id","firestore","parent","recursivelyMapStorageUrls","async","fireWrapper","fieldValue","has","src","getDownloadURL","ref","storage","Promise","all","parseFireStoreDocument","doc","dataWithRefs","refDocs","d","set","applyRefDocs","getAbsolutePath","rootRef","relativePath","Error","rootRefValue","withSlashes","join","split","length","slice","joinPaths","translateDocToFirestore","uploads","recusivelyParseObjectValue","fieldDotsPath","refPath","fieldSlashesPath","rawFile","FirebaseWrapper","_app","_firestore","_storage","_auth","options","inputOptions","firebaseConfig","optionsSafe","window","app","getApps","getApp","initializeApp","ObtainFirebaseApp","getFirestore","getStorage","getAuth","dbGetCollection","absolutePath","collection","dbCreateBatch","writeBatch","dbMakeNewId","OnUserLogout","callBack","onAuthStateChanged","user","isLoggedOut","putFile","storagePath","task","uploadBytesResumable","taskResult","rej","then","catch","downloadUrl","t","url","fieldSrc","serverTimestamp","firestoreServerTimestamp","persistenceInput","persistenceResolved","browserLocalPersistence","inMemoryPersistence","browserSessionPersistence","setPersistence","email","password","signInWithEmailAndPassword","signOut","resolve","reject","auth","currentUser","unsubscribe","authGetUserLoggedIn","GetApp","db","AuthClient","optionsInput","persistence","authSetPersistence","params","username","getUserLogin","authSigninEmailPassword","e","HandleAuthLogout","authSignOut","HandleAuthError","errorHttp","status","retrieveStatusTxt","getIdTokenResult","claims","uid","displayName","photoURL","fullName","avatar","authTime","expirationTime","signInProvider","issuedAtTime","token","AuthProvider","VerifyAuthProviderArgs","logging","login","HandleAuthLogin","logout","checkAuth","HandleAuthCheck","checkError","getPermissions","HandleGetPermissions","getIdentity","HandleGetIdentity","getAuthUser","getJWTAuthTime","HandleGetJWTAuthTime","getJWTExpirationTime","HandleGetJWTExpirationTime","getJWTSignInProvider","HandleGetJWTSignInProvider","getJWTClaims","getJWTToken","HandleGetJWTToken","ResourceManager","flogger","resources","resourceName","refresh","collectionQuery","RefreshResource","TryGetResourcePromise","GetResource","resource","initPath","lazyLoading","enabled","collectionRef","collectionOrQuery","applyQuery","newDocs","getDocs","list","forEach","logDocument","docs","collectionPath","docId","docSnap","getDoc","exists","hasBeenInited","pathAbsolute","allResources","associateUsersById","getCurrentUserId","getCurrentUserEmail","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","transformToDb","documentData","r","docPath","u","useFileName","fileNameBits","File","name","fileExtension","pop","parseStoragePath","useFileNamesInStorage","link","saveFile","disableMeta","currentUserIdentifier","getUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","defautCase","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","updateAtSelector","updated_at","GetSelectorsUpdateAt","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","on","snapshot","progress","bytesTransferred","totalBytes","state","relativeFilePaths","storageError","getQueryCursor","Buffer","from","JSON","stringify","docSnapshot","defaultParamsToQueryOptions","filters","pagination","paramsToQuery","filterConstraints","entries","flatMap","where","isNaN","sortConstraints","order","parsedOrder","toLocaleLowerCase","orderBy","getSortConstraints","paginationConstraints","queryConstraints","page","perPage","limit","queryCursor","lastQueryCursor","currentPage","currentPageParams","pageLimit","newQuery","query","startAfter","snapshots","docsLength","findLastQueryCursor","getPaginationConstraints","noPagination","withPagination","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","FirebaseLazyLoadingClient","client","tryGetResource","softDelete","resultsCount","message","total","allCursorsKey","localCursorKeys","newCursors","parse","concat","setQueryCursor","getNextPageParams","getCountFromServer","parsedData","count","filterWithTarget","target","DataProvider","verifyDataProviderArgs","ResetCount","shouldReset","docCount","incrementBy","currentCountRaw","incremented","parseInt","incrementRead","MakeFirestoreLogger","firestoreCostsLogger","persistCount","run","cb","errorMsg","code","statusTxt","regexResult","exec","retrieveStatusCode","errorObj","json","newProviderApi","getList","apiGetList","filterSafe","TryGetResource","softDeleted","filteredData","pageStart","dataPage","fetchedData","GetList","getOne","dataSingle","GetSingleDoc","GetOne","getMany","ids","matchDocSnaps","idObj","matches","snap","permittedData","GetMany","getManyReference","targetField","targetValue","targetIdFilter","GetManyReference","update","parseDataAndUpload","docObj","addUpdatedByFields","docObjTransformed","updateDoc","Update","updateMany","idStr","UpdateMany","create","hasOverridenDocId","overridenId","createData","createDocObj","addCreatedByFields","createDocObjTransformed","setDoc","merge","newId","Create","delete","previousData","DeleteSoft","deleteDoc","Delete","deleteMany","DeleteManySoft","returnData","batch","docToDelete","commit","DeleteMany"],"mappings":"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"}