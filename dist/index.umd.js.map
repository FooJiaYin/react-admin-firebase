{"version":3,"file":"index.umd.js","sources":["../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/firestore-logger.ts","../src/misc/logger/logger.ts","../src/misc/dispatcher.ts","../src/misc/internal.models.ts","../src/misc/translate-from-firestore.ts","../src/misc/document-parser.ts","../src/misc/pathHelper.ts","../src/misc/translate-to-firestore.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/storage-parser.ts","../src/misc/metadata-parser.ts","../src/misc/firebase-models.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/DataProvider.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts"],"sourcesContent":["import { get, isEmpty } from 'lodash';\r\nimport { getFieldReferences, SearchObj } from './objectFlatten';\r\n\r\nexport function sortArray(\r\n  data: Array<{}>,\r\n  field: string,\r\n  dir: 'asc' | 'desc'\r\n): void {\r\n  data.sort((a: {}, b: {}) => {\r\n    const rawA = get(a, field);\r\n    const rawB = get(b, field);\r\n    const isAsc = dir === 'asc';\r\n\r\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\r\n    if (isNumberField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\r\n    if (isStringField) {\r\n      const aParsed = rawA.toLowerCase();\r\n      const bParsed = rawB.toLowerCase();\r\n      return basicSort(aParsed, bParsed, isAsc);\r\n    }\r\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\r\n    if (isDateField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    return basicSort(!!rawA, !!rawB, isAsc);\r\n  });\r\n}\r\n\r\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\r\n  if (aValue > bValue) {\r\n    return isAsc ? 1 : -1;\r\n  }\r\n  if (aValue < bValue) {\r\n    return isAsc ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport function filterArray(\r\n  data: Array<{}>,\r\n  searchFields?: { [field: string]: string | number | boolean | null }\r\n): Array<{}> {\r\n  if (!searchFields || isEmpty(searchFields)) {\r\n    return data;\r\n  }\r\n  const searchObjs: SearchObj[] = [];\r\n  Object.keys(searchFields).map((fieldName) => {\r\n    const fieldValue = searchFields[fieldName];\r\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\r\n    searchObjs.push(...getSubObjects);\r\n  });\r\n  const filtered = data.filter((row) =>\r\n    searchObjs.reduce((acc, cur) => {\r\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\r\n      return res && acc;\r\n    }, true as boolean)\r\n  );\r\n  return filtered;\r\n}\r\n\r\nexport function doesRowMatch(\r\n  row: {},\r\n  searchField: string,\r\n  searchValue: any\r\n): boolean {\r\n  const searchThis = get(row, searchField);\r\n  const bothAreFalsey = !searchThis && !searchValue;\r\n  if (bothAreFalsey) {\r\n    return true;\r\n  }\r\n  const nothingToSearch = !searchThis;\r\n  if (nothingToSearch) {\r\n    return false;\r\n  }\r\n  const isStringSearch = typeof searchValue === 'string';\r\n  if (isStringSearch) {\r\n    return searchThis\r\n      .toString()\r\n      .toLowerCase()\r\n      .includes(searchValue.toLowerCase());\r\n  }\r\n  const isBooleanOrNumber =\r\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\r\n  if (isBooleanOrNumber) {\r\n    return searchThis === searchValue;\r\n  }\r\n  const isArraySearch = Array.isArray(searchValue);\r\n  if (isArraySearch) {\r\n    return searchValue.includes(searchThis);\r\n  }\r\n  return false;\r\n}\r\n","type SearchValues = {} | number | string | boolean | null;\r\ntype SearchValue = SearchValues | SearchValue[];\r\n\r\nexport interface SearchObj {\r\n  searchField: string;\r\n  searchValue: SearchValue;\r\n}\r\nexport function getFieldReferences(\r\n  fieldName: string,\r\n  value: {} | SearchValue\r\n): SearchObj[] {\r\n  const isFalsy = !value;\r\n  const isSimple =\r\n    isFalsy ||\r\n    typeof value === 'string' ||\r\n    typeof value === 'number' ||\r\n    typeof value === 'boolean';\r\n\r\n  if (isSimple) {\r\n    return [\r\n      {\r\n        searchField: fieldName,\r\n        searchValue: value as SearchValue,\r\n      },\r\n    ];\r\n  }\r\n  const tree = {} as Record<string, SearchValue>;\r\n  tree[fieldName] = value;\r\n  return objectFlatten(tree);\r\n}\r\n\r\nexport function objectFlatten(tree: {}): SearchObj[] {\r\n  var leaves: SearchObj[] = [];\r\n  var recursivelyWalk = (obj: any, path: string | null) => {\r\n    path = path || '';\r\n    for (var key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        const objVal = obj && obj[key];\r\n        const currentPath = !!path ? path + '.' + key : key;\r\n        const isWalkable =\r\n          typeof objVal === 'object' || objVal instanceof Array;\r\n        if (isWalkable) {\r\n          recursivelyWalk(objVal, currentPath);\r\n        } else {\r\n          leaves.push({ searchField: currentPath, searchValue: objVal });\r\n        }\r\n      }\r\n    }\r\n  };\r\n  recursivelyWalk(tree, null);\r\n  return leaves;\r\n}\r\n","type LogFn = (...args: any) => void;\r\n\r\nexport const LogNoOp: LogFn = (...args: any) => null;\r\n\r\nexport class LoggerBase {\r\n  constructor(private title: string, private cacheEnabledKey: string) {}\r\n\r\n  private isEnabled() {\r\n    return !!localStorage.getItem(this.cacheEnabledKey);\r\n  }\r\n\r\n  SetEnabled(isEnabled: boolean) {\r\n    if (isEnabled) {\r\n      localStorage.setItem(this.cacheEnabledKey, 'true');\r\n    } else {\r\n      localStorage.removeItem(this.cacheEnabledKey);\r\n    }\r\n  }\r\n\r\n  public get log() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.log.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get warn() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.warn.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get error() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.error.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n}\r\n","import { RAFirebaseOptions } from 'providers/options';\r\nimport { LoggerBase, LogNoOp } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\r\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\r\n\r\nconst KEY_SINGLE = 'firecosts-single-reads';\r\n\r\nexport interface IFirestoreLogger {\r\n  logDocument: (count: number) => Function;\r\n  SetEnabled: (isEnabled: boolean) => void;\r\n  ResetCount: (shouldReset: boolean) => void;\r\n}\r\n\r\nexport function MakeFirestoreLogger(\r\n  options: RAFirebaseOptions\r\n): IFirestoreLogger {\r\n  function notEnabled() {\r\n    return !options?.lazyLoading?.enabled;\r\n  }\r\n\r\n  function incrementRead(incrementBy = 1) {\r\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\r\n    const currentCount = parseInt(currentCountRaw) || 0;\r\n    const incremented = currentCount + incrementBy;\r\n    localStorage.setItem(KEY_SINGLE, incremented + '');\r\n    return incremented;\r\n  }\r\n  function clearCache() {\r\n    localStorage.removeItem(KEY_SINGLE);\r\n  }\r\n  return {\r\n    SetEnabled(isEnabled: boolean) {\r\n      logger.SetEnabled(isEnabled);\r\n    },\r\n    ResetCount(shouldReset: boolean) {\r\n      shouldReset && clearCache();\r\n    },\r\n    logDocument(docCount: number) {\r\n      if (notEnabled()) {\r\n        return LogNoOp;\r\n      }\r\n      const count = incrementRead(docCount);\r\n      const suffix = `+${docCount} (session total=${count} documents read)`;\r\n      const boundLogFn: (...args: any) => void = logger.log.bind(\r\n        console,\r\n        suffix\r\n      );\r\n      return boundLogFn;\r\n    },\r\n  };\r\n}\r\n","import { LoggerBase } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\r\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\r\n\r\nexport const log = logger.log;\r\nexport const logError = logger.error;\r\nexport const logWarn = logger.warn;\r\n","import { log } from './logger';\r\n\r\nexport type DispatchEvent =\r\n  | 'FILE_UPLOAD_WILL_START'\r\n  | 'FILE_UPLOAD_PROGRESS'\r\n  | 'FILE_UPLOAD_PAUSED'\r\n  | 'FILE_UPLOAD_RUNNING'\r\n  | 'FILE_UPLOAD_CANCELED'\r\n  | 'FILE_UPLOAD_COMPLETE'\r\n  | 'FILE_SAVED';\r\n\r\nexport function dispatch(\r\n  eventName: DispatchEvent,\r\n  fileName: string,\r\n  data?: any\r\n): void {\r\n  const eventMonitor = document.getElementById('eventMonitor');\r\n  if (!eventMonitor) {\r\n    log(\r\n      `eventMonitor not found to dispatch event ${eventName} for ${fileName}`\r\n    );\r\n    return;\r\n  }\r\n  const eventData = { fileName, data };\r\n  let event = new CustomEvent(eventName, { detail: eventData });\r\n  eventMonitor.dispatchEvent(event);\r\n}\r\n","export const REF_INDENTIFIER = '___REF_FULLPATH_';\r\n\r\nexport interface ParsedRefDoc {\r\n  ___refpath: string;\r\n  ___refid: string;\r\n}\r\n","import { getDownloadURL, ref } from 'firebase/storage';\r\nimport { has, set } from 'lodash';\r\nimport { IFirebaseWrapper } from 'providers/database';\r\nimport { FireStoreDocumentRef } from './firebase-models';\r\nimport { REF_INDENTIFIER } from './internal.models';\r\nimport { logError } from './logger';\r\n\r\nexport interface RefDocFound {\r\n  fieldPath: string;\r\n  refDocPath: string;\r\n}\r\n\r\nexport interface FromFirestoreResult {\r\n  parsedDoc: any;\r\n  refdocs: RefDocFound[];\r\n}\r\n\r\nexport function translateDocFromFirestore(obj: any) {\r\n  const isObject = !!obj && typeof obj === 'object';\r\n  const result: FromFirestoreResult = {\r\n    parsedDoc: {},\r\n    refdocs: [],\r\n  };\r\n  if (!isObject) {\r\n    return result;\r\n  }\r\n  Object.keys(obj).map((key) => {\r\n    const value = obj[key];\r\n    obj[key] = recusivelyCheckObjectValue(value, key, result);\r\n  });\r\n  result.parsedDoc = obj;\r\n  return result;\r\n}\r\n\r\nexport function recusivelyCheckObjectValue(\r\n  input: any,\r\n  fieldPath: string,\r\n  result: FromFirestoreResult\r\n): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as any[]).map((value, index) =>\r\n      recusivelyCheckObjectValue(value, `${fieldPath}.${index}`, result)\r\n    );\r\n  }\r\n  const isDocumentReference = isInputADocReference(input);\r\n  if (isDocumentReference) {\r\n    const documentReference = input as FireStoreDocumentRef;\r\n    result.refdocs.push({\r\n      fieldPath: fieldPath,\r\n      refDocPath: documentReference.path,\r\n    });\r\n    return documentReference.id;\r\n  }\r\n  const isObject = typeof input === 'object';\r\n  if (isObject) {\r\n    Object.keys(input).map((key) => {\r\n      const value = input[key];\r\n      input[key] = recusivelyCheckObjectValue(value, key, result);\r\n    });\r\n    return input;\r\n  }\r\n  return input;\r\n}\r\n\r\nfunction isInputADocReference(input: any): boolean {\r\n  const isDocumentReference =\r\n    typeof input.id === 'string' &&\r\n    typeof input.firestore === 'object' &&\r\n    typeof input.parent === 'object' &&\r\n    typeof input.path === 'string';\r\n  return isDocumentReference;\r\n}\r\n\r\nexport function applyRefDocs(doc: any, refDocs: RefDocFound[]) {\r\n  refDocs.map((d) => {\r\n    set(doc, REF_INDENTIFIER + d.fieldPath, d.refDocPath);\r\n  });\r\n  return doc;\r\n}\r\n\r\nexport const recursivelyMapStorageUrls = async (\r\n  fireWrapper: IFirebaseWrapper,\r\n  fieldValue: any\r\n): Promise<any> => {\r\n  const isPrimitive = !fieldValue || typeof fieldValue !== 'object';\r\n  if (isPrimitive) {\r\n    return fieldValue;\r\n  }\r\n  const isFileField = has(fieldValue, 'src');\r\n  if (isFileField) {\r\n    try {\r\n      const src = await getDownloadURL(\r\n        ref(fireWrapper.storage(), fieldValue.src)\r\n      );\r\n      return {\r\n        ...fieldValue,\r\n        src,\r\n      };\r\n    } catch (error) {\r\n      logError(`Error when getting download URL`, {\r\n        error,\r\n      });\r\n      return fieldValue;\r\n    }\r\n  }\r\n  const isArray = Array.isArray(fieldValue);\r\n  if (isArray) {\r\n    return Promise.all(\r\n      (fieldValue as any[]).map(async (value, index) => {\r\n        (fieldValue as any[])[index] = await recursivelyMapStorageUrls(fireWrapper, value);\r\n      })\r\n    );\r\n  }\r\n  const isDocumentReference = isInputADocReference(fieldValue);\r\n  if (isDocumentReference) {\r\n    return fieldValue;\r\n  }\r\n  const isObject = !isArray && typeof fieldValue === 'object';\r\n  if (isObject) {\r\n    return Promise.all(\r\n      Object.keys(fieldValue).map(async (key) => {\r\n        const value = fieldValue[key];\r\n        (fieldValue as any)[key] = await recursivelyMapStorageUrls(fireWrapper, value);\r\n      })\r\n    );\r\n  }\r\n};\r\n","import {\r\n  FireStoreDocumentSnapshot,\r\n  FireStoreQueryDocumentSnapshot,\r\n} from './firebase-models';\r\nimport { logWarn } from './logger';\r\nimport * as ra from './react-admin-models';\r\nimport {\r\n  applyRefDocs,\r\n  translateDocFromFirestore,\r\n} from './translate-from-firestore';\r\n\r\nexport function parseFireStoreDocument<T extends ra.Record>(\r\n  doc: FireStoreQueryDocumentSnapshot | FireStoreDocumentSnapshot | undefined\r\n): T {\r\n  if (!doc) {\r\n    logWarn('parseFireStoreDocument: no doc', { doc });\r\n    return {} as T;\r\n  }\r\n  const data = doc.data();\r\n  const result = translateDocFromFirestore(data);\r\n  const dataWithRefs = applyRefDocs(result.parsedDoc, result.refdocs);\r\n  // React Admin requires an id field on every document,\r\n  // So we can just use the firestore document id\r\n  return { id: doc.id, ...dataWithRefs } as T;\r\n}\r\n","import path from 'path-browserify';\r\n\r\nexport function getAbsolutePath(\r\n  rootRef: undefined | string | (() => string),\r\n  relativePath: string | null\r\n): string {\r\n  if (!rootRef) {\r\n    return relativePath + '';\r\n  }\r\n  if (!relativePath) {\r\n    throw new Error(\r\n      'Resource name must be a string of length greater than 0 characters'\r\n    );\r\n  }\r\n  const rootRefValue = typeof rootRef === 'string' ? rootRef : rootRef();\r\n  const withSlashes = path.join('/', rootRefValue, '/', relativePath, '/');\r\n  const slashCount = withSlashes.split('/').length - 1;\r\n  if (slashCount % 2) {\r\n    throw new Error(`The rootRef path must point to a \"document\"\r\n    not a \"collection\"e.g. /collection/document/ or\r\n    /collection/document/collection/document/`);\r\n  }\r\n  return withSlashes.slice(1, -1);\r\n}\r\n\r\nexport function joinPaths(...args: string[]) {\r\n  return path.join(...args);\r\n}\r\n","import { REF_INDENTIFIER } from './internal.models';\r\n\r\ninterface ParsedUpload {\r\n  fieldDotsPath: string;\r\n  fieldSlashesPath: string;\r\n  rawFile: File | any;\r\n}\r\n\r\ninterface ParsedDocRef {\r\n  fieldDotsPath: string;\r\n  refPath: string;\r\n}\r\n\r\ninterface ParseResult {\r\n  parsedDoc: any;\r\n  uploads: ParsedUpload[];\r\n  refdocs: ParsedDocRef[];\r\n}\r\n\r\nexport function translateDocToFirestore(obj: any): ParseResult {\r\n  const isObject = !!obj && typeof obj === 'object';\r\n  const result: ParseResult = {\r\n    uploads: [],\r\n    refdocs: [],\r\n    parsedDoc: {},\r\n  };\r\n  if (!isObject) {\r\n    return result;\r\n  }\r\n  Object.keys(obj).map((key) => {\r\n    const value = obj[key];\r\n    recusivelyParseObjectValue(value, key, result);\r\n  });\r\n  result.parsedDoc = obj;\r\n  return result;\r\n}\r\n\r\nexport function recusivelyParseObjectValue(\r\n  input: any,\r\n  fieldPath: string,\r\n  result: ParseResult\r\n): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isRefField =\r\n    typeof fieldPath === 'string' && fieldPath.includes(REF_INDENTIFIER);\r\n  if (isRefField) {\r\n    const refDocFullPath = input as string;\r\n    result.refdocs.push({\r\n      fieldDotsPath: fieldPath,\r\n      refPath: refDocFullPath,\r\n    });\r\n    return;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as []).map((value, index) =>\r\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, result)\r\n    );\r\n  }\r\n  const isFileField = !!input && input.hasOwnProperty('rawFile');\r\n  if (isFileField) {\r\n    result.uploads.push({\r\n      fieldDotsPath: fieldPath,\r\n      fieldSlashesPath: fieldPath.split('.').join('/'),\r\n      rawFile: input.rawFile,\r\n    });\r\n    delete input.rawFile;\r\n    return;\r\n  }\r\n  Object.keys(input).map((key) => {\r\n    const value = input[key];\r\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, result);\r\n  });\r\n  return input;\r\n}\r\n","import { FirebaseApp, getApp, getApps, initializeApp } from 'firebase/app';\r\nimport {\r\n  browserLocalPersistence,\r\n  browserSessionPersistence,\r\n  getAuth,\r\n  inMemoryPersistence,\r\n  onAuthStateChanged,\r\n  Persistence,\r\n  signInWithEmailAndPassword,\r\n  signOut,\r\n} from 'firebase/auth';\r\nimport {\r\n  collection,\r\n  doc,\r\n  getFirestore,\r\n  serverTimestamp as firestoreServerTimestamp,\r\n  writeBatch,\r\n} from 'firebase/firestore';\r\nimport {\r\n  getDownloadURL,\r\n  getStorage,\r\n  ref,\r\n  uploadBytesResumable,\r\n} from 'firebase/storage';\r\nimport {\r\n  FireApp,\r\n  FireAuth,\r\n  FireAuthUserCredentials,\r\n  FireStorage,\r\n  FireStoragePutFileResult,\r\n  FireStore,\r\n  FireStoreBatch,\r\n  FireStoreCollectionRef,\r\n  FireUploadTaskSnapshot,\r\n  FireUser,\r\n} from 'misc/firebase-models';\r\nimport { log } from '../../../misc';\r\nimport { RAFirebaseOptions } from '../../options';\r\nimport { IFirebaseWrapper } from './IFirebaseWrapper';\r\n\r\nexport class FirebaseWrapper implements IFirebaseWrapper {\r\n  private readonly _app: FireApp;\r\n  private readonly _firestore: FireStore;\r\n  private readonly _storage: FireStorage;\r\n  private readonly _auth: FireAuth;\r\n  public options: RAFirebaseOptions;\r\n\r\n  constructor(inputOptions: RAFirebaseOptions | undefined, firebaseConfig: {}) {\r\n    const optionsSafe = inputOptions || {};\r\n    this.options = optionsSafe;\r\n    this._app = (window as any)['_app'] = ObtainFirebaseApp(\r\n      firebaseConfig,\r\n      optionsSafe\r\n    );\r\n    this._firestore = getFirestore(this._app);\r\n    this._storage = getStorage(this._app);\r\n    this._auth = getAuth(this._app);\r\n  }\r\n  dbGetCollection(absolutePath: string): FireStoreCollectionRef {\r\n    return collection(this._firestore, absolutePath);\r\n  }\r\n  dbCreateBatch(): FireStoreBatch {\r\n    return writeBatch(this._firestore);\r\n  }\r\n  dbMakeNewId(): string {\r\n    return doc(collection(this._firestore, 'collections')).id;\r\n  }\r\n\r\n  public OnUserLogout(callBack: (u: FireUser | null) => any) {\r\n    this._auth.onAuthStateChanged((user) => {\r\n      const isLoggedOut = !user;\r\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\r\n      if (isLoggedOut) {\r\n        callBack(user);\r\n      }\r\n    });\r\n  }\r\n  putFile(storagePath: string, rawFile: any): FireStoragePutFileResult {\r\n    const task = uploadBytesResumable(ref(this._storage, storagePath), rawFile);\r\n    const taskResult = new Promise<FireUploadTaskSnapshot>((res, rej) =>\r\n      task.then(res).catch(rej)\r\n    );\r\n\r\n    const downloadUrl = taskResult\r\n      .then((t) => getDownloadURL(t.ref))\r\n      .then((url) => url as string);\r\n\r\n    return {\r\n      task,\r\n      taskResult,\r\n      downloadUrl,\r\n    };\r\n  }\r\n  async getStorageDownloadUrl(fieldSrc: string): Promise<string> {\r\n    return getDownloadURL(ref(this._storage, fieldSrc));\r\n  }\r\n  public serverTimestamp() {\r\n    // This line doesn't work for some reason, might be firebase sdk.\r\n    return firestoreServerTimestamp();\r\n  }\r\n\r\n  async authSetPersistence(persistenceInput: 'session' | 'local' | 'none') {\r\n    let persistenceResolved: Persistence;\r\n    switch (persistenceInput) {\r\n      case 'local':\r\n        persistenceResolved = browserLocalPersistence;\r\n        break;\r\n      case 'none':\r\n        persistenceResolved = inMemoryPersistence;\r\n        break;\r\n      case 'session':\r\n      default:\r\n        persistenceResolved = browserSessionPersistence;\r\n        break;\r\n    }\r\n\r\n    log('setPersistence', { persistenceInput, persistenceResolved });\r\n\r\n    return this._auth\r\n      .setPersistence(persistenceResolved)\r\n      .catch((error) => console.error(error));\r\n  }\r\n  async authSigninEmailPassword(\r\n    email: string,\r\n    password: string\r\n  ): Promise<FireAuthUserCredentials> {\r\n    const user = await signInWithEmailAndPassword(this._auth, email, password);\r\n    return user;\r\n  }\r\n  async authSignOut(): Promise<void> {\r\n    return signOut(this._auth);\r\n  }\r\n  async authGetUserLoggedIn(): Promise<FireUser> {\r\n    return new Promise((resolve, reject) => {\r\n      const auth = this._auth;\r\n      if (auth.currentUser) return resolve(auth.currentUser);\r\n      const unsubscribe = onAuthStateChanged(this._auth, (user) => {\r\n        unsubscribe();\r\n        if (user) {\r\n          resolve(user);\r\n        } else {\r\n          reject();\r\n        }\r\n      });\r\n    });\r\n  }\r\n  public async GetUserLogin(): Promise<FireUser> {\r\n    return this.authGetUserLoggedIn();\r\n  }\r\n\r\n  /** @deprecated */\r\n  public auth(): FireAuth {\r\n    return this._auth;\r\n  }\r\n  /** @deprecated */\r\n  public storage(): FireStorage {\r\n    return this._storage;\r\n  }\r\n  /** @deprecated */\r\n  public GetApp(): FireApp {\r\n    return this._app;\r\n  }\r\n  /** @deprecated */\r\n  public db(): FireStore {\r\n    return this._firestore;\r\n  }\r\n}\r\n\r\nfunction ObtainFirebaseApp(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): FirebaseApp {\r\n  if (options.app) {\r\n    return options.app;\r\n  }\r\n  const apps = getApps();\r\n\r\n  const isInitialized = !!apps?.length;\r\n\r\n  if (isInitialized) {\r\n    return getApp();\r\n  } else {\r\n    return initializeApp(firebaseConfig);\r\n  }\r\n}\r\n","import { log, logger, logWarn, retrieveStatusTxt } from '../misc';\r\nimport { FireUser } from '../misc/firebase-models';\r\nimport {\r\n  AuthProvider as RaAuthProvider,\r\n  UserIdentity,\r\n} from '../misc/react-admin-models';\r\nimport { messageTypes } from './../misc/messageTypes';\r\nimport { IFirebaseWrapper } from './database';\r\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\r\nimport { RAFirebaseOptions } from './options';\r\n\r\nclass AuthClient {\r\n  private fireWrapper: IFirebaseWrapper;\r\n\r\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\r\n    const options = optionsInput || {};\r\n    log('Auth Client: initializing...', { firebaseConfig, options });\r\n    this.fireWrapper = new FirebaseWrapper(options, firebaseConfig);\r\n    options.persistence && this.setPersistence(options.persistence);\r\n  }\r\n\r\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\r\n    return this.fireWrapper.authSetPersistence(persistenceInput);\r\n  }\r\n\r\n  public async HandleAuthLogin(params: { username: string; password: string }) {\r\n    const { username, password } = params;\r\n\r\n    if (username && password) {\r\n      try {\r\n        const user = await this.fireWrapper.authSigninEmailPassword(\r\n          username,\r\n          password\r\n        );\r\n        log('HandleAuthLogin: user sucessfully logged in', { user });\r\n        return user;\r\n      } catch (e) {\r\n        log('HandleAuthLogin: invalid credentials', { params });\r\n        throw new Error('Login error: invalid credentials');\r\n      }\r\n    } else {\r\n      return this.getUserLogin();\r\n    }\r\n  }\r\n\r\n  public HandleAuthLogout() {\r\n    return this.fireWrapper.authSignOut();\r\n  }\r\n\r\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\r\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\r\n    const status = !!errorHttp && errorHttp.status;\r\n    const statusTxt = retrieveStatusTxt(status);\r\n    if (statusTxt === 'ok') {\r\n      log('API is actually authenticated');\r\n      return Promise.resolve();\r\n    }\r\n    logWarn('Received authentication error from API');\r\n    return Promise.reject();\r\n  }\r\n\r\n  public async HandleAuthCheck(): Promise<any> {\r\n    return this.getUserLogin();\r\n  }\r\n\r\n  public getUserLogin(): Promise<FireUser> {\r\n    return this.fireWrapper.authGetUserLoggedIn();\r\n  }\r\n\r\n  public async HandleGetPermissions() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.claims;\r\n    } catch (e) {\r\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetIdentity(): Promise<UserIdentity> {\r\n    try {\r\n      const { uid, displayName, photoURL } = await this.getUserLogin();\r\n      const identity: UserIdentity = {\r\n        id: uid,\r\n        fullName: `${displayName ?? ''}`,\r\n        avatar: `${photoURL ?? ''}`,\r\n      };\r\n      return identity;\r\n    } catch (e) {\r\n      log('HandleGetIdentity: no user is logged in', {\r\n        e,\r\n      });\r\n      return null as any;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTAuthTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.authTime;\r\n    } catch (e) {\r\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTExpirationTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.expirationTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTSignInProvider() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.signInProvider;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTIssuedAtTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.issuedAtTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTToken() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.token;\r\n    } catch (e) {\r\n      log('HandleGetJWTToken: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function AuthProvider(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): ReactAdminFirebaseAuthProvider {\r\n  VerifyAuthProviderArgs(firebaseConfig, options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  const auth = new AuthClient(firebaseConfig, options);\r\n\r\n  const provider: ReactAdminFirebaseAuthProvider = {\r\n    // React Admin Interface\r\n    login: (params) => auth.HandleAuthLogin(params),\r\n    logout: () => auth.HandleAuthLogout(),\r\n    checkAuth: () => auth.HandleAuthCheck(),\r\n    checkError: (error) => auth.HandleAuthError(error),\r\n    getPermissions: () => auth.HandleGetPermissions(),\r\n    getIdentity: () => auth.HandleGetIdentity(),\r\n    // Custom Functions\r\n    getAuthUser: () => auth.getUserLogin(),\r\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\r\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\r\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\r\n    getJWTClaims: () => auth.HandleGetPermissions(),\r\n    getJWTToken: () => auth.HandleGetJWTToken(),\r\n  };\r\n  return provider;\r\n}\r\n\r\nexport type ReactAdminFirebaseAuthProvider = RaAuthProvider & {\r\n  // Custom Functions\r\n  getAuthUser: () => Promise<FireUser>;\r\n  getJWTAuthTime: () => Promise<string | null>;\r\n  getJWTExpirationTime: () => Promise<string | null>;\r\n  getJWTSignInProvider: () => Promise<string | null>;\r\n  getJWTClaims: () => Promise<{ [key: string]: any } | null>;\r\n  getJWTToken: () => Promise<string | null>;\r\n};\r\n\r\nfunction VerifyAuthProviderArgs(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n}\r\n","// From firebase SDK\r\n\r\nimport { logError } from './logger';\r\n\r\n// tslint:disable-next-line:max-line-length\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\r\n  // Make sure any successful status is OK.\r\n  if (status >= 200 && status < 300) {\r\n    return 'ok';\r\n  }\r\n  switch (status) {\r\n    case 401: // 'unauthenticated'\r\n    case 403: // 'permission-denied'\r\n      return 'unauthenticated';\r\n\r\n    case 0: // 'internal'\r\n    case 400: // 'invalid-argument'\r\n    case 404: // 'not-found'\r\n    case 409: // 'aborted'\r\n    case 429: // 'resource-exhausted'\r\n    case 499: // 'cancelled'\r\n    case 500: // 'internal'\r\n    case 501: // 'unimplemented'\r\n    case 503: // 'unavailable'\r\n    case 504: // 'deadline-exceeded'\r\n    default:\r\n      // ignore\r\n      return 'ok';\r\n  }\r\n}\r\n\r\n// From firebase SDK\r\n// tslint:disable-next-line:max-line-length\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusCode(statusTxt: string): number {\r\n  // Make sure any successful status is OK.\r\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\r\n  const status = Array.isArray(regexResult) && regexResult[1];\r\n  if (!status) {\r\n    logError('unknown StatusCode ', { statusTxt });\r\n  }\r\n  switch (status) {\r\n    case 'unauthenticated':\r\n      return 401;\r\n    case 'permission-denied':\r\n      return 403;\r\n    case 'internal':\r\n      return 0;\r\n    case 'invalid-argument':\r\n      return 400;\r\n    case 'not-found':\r\n      return 404;\r\n    case 'aborted':\r\n      return 409;\r\n    case 'resource-exhausted':\r\n      return 429;\r\n    case 'cancelled':\r\n      return 499;\r\n    case 'internal':\r\n      return 500;\r\n    case 'unimplemented':\r\n      return 501;\r\n    case 'unavailable':\r\n      return 503;\r\n    case 'deadline-exceeded':\r\n      return 504;\r\n    default:\r\n      return 200;\r\n  }\r\n}\r\n","import { doc, getDoc, getDocs } from 'firebase/firestore';\r\nimport { FireStoreCollectionRef, FireStoreQuery } from 'misc/firebase-models';\r\nimport {\r\n  getAbsolutePath,\r\n  IFirestoreLogger,\r\n  log,\r\n  logWarn,\r\n  messageTypes,\r\n  parseFireStoreDocument,\r\n} from '../../misc';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\r\n\r\ntype IResourceItem = {} & { id: string; deleted?: boolean };\r\nexport interface IResource {\r\n  path: string;\r\n  pathAbsolute: string;\r\n  collection: FireStoreCollectionRef;\r\n  list: Array<IResourceItem>;\r\n}\r\n\r\nexport class ResourceManager {\r\n  private resources: Record<string, IResource> = {};\r\n\r\n  constructor(\r\n    private fireWrapper: IFirebaseWrapper,\r\n    private options: RAFirebaseOptions,\r\n    private flogger: IFirestoreLogger\r\n  ) {\r\n    this.fireWrapper.OnUserLogout(() => {\r\n      this.resources = {};\r\n    });\r\n  }\r\n\r\n  public async TryGetResource(\r\n    resourceName: string,\r\n    refresh?: 'REFRESH',\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    if (refresh) {\r\n      await this.RefreshResource(resourceName, collectionQuery);\r\n    }\r\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n\r\n  public GetResource(relativePath: string): IResource {\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async TryGetResourcePromise(\r\n    relativePath: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    log('resourceManager.TryGetResourcePromise', {\r\n      relativePath,\r\n      collectionQuery,\r\n    });\r\n    await this.initPath(relativePath);\r\n\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async RefreshResource(\r\n    relativePath: string,\r\n    collectionQuery: messageTypes.CollectionQueryType | undefined\r\n  ) {\r\n    if (this.options?.lazyLoading?.enabled) {\r\n      logWarn('resourceManager.RefreshResource', {\r\n        warn: 'RefreshResource is not available in lazy loading mode',\r\n      });\r\n      throw new Error(\r\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\r\n      );\r\n    }\r\n\r\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\r\n    await this.initPath(relativePath);\r\n    const resource = this.resources[relativePath];\r\n\r\n    const collectionRef = resource.collection;\r\n    const collectionOrQuery = this.applyQuery(collectionRef, collectionQuery);\r\n    const newDocs = await getDocs(collectionOrQuery);\r\n\r\n    resource.list = [];\r\n    newDocs.forEach((d) =>\r\n      resource.list.push(parseFireStoreDocument<IResourceItem>(d))\r\n    );\r\n\r\n    const count = newDocs.docs.length;\r\n    this.flogger.logDocument(count)();\r\n    log('resourceManager.RefreshResource', {\r\n      newDocs,\r\n      resource,\r\n      collectionPath: collectionRef.path,\r\n    });\r\n  }\r\n\r\n  public async GetSingleDoc(relativePath: string, docId: string): Promise<any> {\r\n    await this.initPath(relativePath);\r\n    const resource = this.GetResource(relativePath);\r\n    this.flogger.logDocument(1)();\r\n    const docSnap = await getDoc(doc(resource.collection, docId));\r\n    if (!docSnap.exists) {\r\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\r\n    }\r\n    const result = parseFireStoreDocument(docSnap);\r\n    log('resourceManager.GetSingleDoc', {\r\n      relativePath,\r\n      resource,\r\n      docId,\r\n      docSnap,\r\n      result,\r\n    });\r\n    return result;\r\n  }\r\n\r\n  private async initPath(relativePath: string): Promise<void> {\r\n    const rootRef = this.options && this.options.rootRef;\r\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\r\n    const hasBeenInited = !!this.resources[relativePath];\r\n    log('resourceManager.initPath()', {\r\n      absolutePath,\r\n      hasBeenInited,\r\n    });\r\n    if (hasBeenInited) {\r\n      log('resourceManager.initPath() has been initialized already...');\r\n      return;\r\n    }\r\n    const collection = this.fireWrapper.dbGetCollection(absolutePath);\r\n    const list: Array<IResourceItem> = [];\r\n    const resource: IResource = {\r\n      collection,\r\n      list,\r\n      path: relativePath,\r\n      pathAbsolute: absolutePath,\r\n    };\r\n    this.resources[relativePath] = resource;\r\n    log('resourceManager.initPath() setting resource...', {\r\n      resource,\r\n      allResources: this.resources,\r\n      collection: collection,\r\n      collectionPath: collection.path,\r\n    });\r\n  }\r\n\r\n  public async getUserIdentifier(): Promise<string> {\r\n    const identifier = this.options.associateUsersById\r\n      ? await this.getCurrentUserId()\r\n      : await this.getCurrentUserEmail();\r\n    return identifier;\r\n  }\r\n\r\n  private async getCurrentUserEmail() {\r\n    const user = await this.fireWrapper.authGetUserLoggedIn();\r\n    if (user) {\r\n      return user.email as string;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n  private async getCurrentUserId() {\r\n    const user = await this.fireWrapper.authGetUserLoggedIn();\r\n    if (user) {\r\n      return user.uid;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n\r\n  private applyQuery(\r\n    collection: FireStoreCollectionRef,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): FireStoreCollectionRef | FireStoreQuery {\r\n    const collRef = collectionQuery ? collectionQuery(collection) : collection;\r\n\r\n    log('resourceManager.applyQuery() ...', {\r\n      collection,\r\n      collectionQuery: (collectionQuery || '-').toString(),\r\n      collRef,\r\n    });\r\n    return collRef;\r\n  }\r\n}\r\n","import { doc } from 'firebase/firestore';\r\nimport { get, set } from 'lodash';\r\nimport {\r\n  AddCreatedByFields,\r\n  AddUpdatedByFields,\r\n  dispatch,\r\n  IFirestoreLogger,\r\n  log,\r\n  logError,\r\n  parseStoragePath,\r\n  translateDocToFirestore,\r\n} from '../../misc';\r\nimport {\r\n  TASK_CANCELED,\r\n  TASK_PAUSED,\r\n  TASK_RUNNING,\r\n} from '../../misc/firebase-models';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\r\nimport { IResource, ResourceManager } from './ResourceManager';\r\n\r\nexport class FireClient {\r\n  public rm: ResourceManager;\r\n\r\n  constructor(\r\n    public fireWrapper: IFirebaseWrapper,\r\n    public options: RAFirebaseOptions,\r\n    public flogger: IFirestoreLogger\r\n  ) {\r\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\r\n  }\r\n\r\n  public checkRemoveIdField(obj: any, docId: string) {\r\n    if (!this.options.dontAddIdFieldToDoc) {\r\n      obj.id = docId;\r\n    }\r\n  }\r\n\r\n  public transformToDb(\r\n    resourceName: string,\r\n    documentData: any,\r\n    docId: string\r\n  ): any {\r\n    if (typeof this.options.transformToDb === 'function') {\r\n      return this.options.transformToDb(resourceName, documentData, docId);\r\n    }\r\n    return documentData;\r\n  }\r\n\r\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\r\n    if (!data) {\r\n      return data;\r\n    }\r\n    const docPath = doc(r.collection, id).path;\r\n\r\n    const result = translateDocToFirestore(data);\r\n    const uploads = result.uploads;\r\n    await Promise.all(\r\n      uploads.map(async (u) => {\r\n        const storagePath = parseStoragePath(\r\n          u.rawFile,\r\n          docPath,\r\n          u.fieldDotsPath,\r\n          !!this.options.useFileNamesInStorage\r\n        );\r\n        const link = await this.saveFile(storagePath, u.rawFile);\r\n        set(data, u.fieldDotsPath + '.src', link);\r\n      })\r\n    );\r\n    return data;\r\n  }\r\n\r\n  public async addCreatedByFields(obj: any) {\r\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  public async addUpdatedByFields(obj: any) {\r\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  private async saveFile(\r\n    storagePath: string,\r\n    rawFile: any\r\n  ): Promise<string | undefined> {\r\n    log('saveFile() saving file...', { storagePath, rawFile });\r\n    try {\r\n      const { task, taskResult, downloadUrl } = this.fireWrapper.putFile(\r\n        storagePath,\r\n        rawFile\r\n      );\r\n      const { name } = rawFile;\r\n      // monitor upload status & progress\r\n      dispatch('FILE_UPLOAD_WILL_START', name);\r\n      task.on('state_changed', (snapshot) => {\r\n        const progress =\r\n          (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\r\n        log('Upload is ' + progress + '% done');\r\n        dispatch('FILE_UPLOAD_PROGRESS', name, progress);\r\n        switch (snapshot.state) {\r\n          case TASK_PAUSED:\r\n            log('Upload is paused');\r\n            dispatch('FILE_UPLOAD_PAUSED', name);\r\n            break;\r\n          case TASK_RUNNING:\r\n            log('Upload is running');\r\n            dispatch('FILE_UPLOAD_RUNNING', name);\r\n            break;\r\n          case TASK_CANCELED:\r\n            log('Upload has been canceled');\r\n            dispatch('FILE_UPLOAD_CANCELED', name);\r\n            break;\r\n          // case storage.TaskState.ERROR:\r\n          // already handled by catch\r\n          // case storage.TaskState.SUCCESS:\r\n          // already handled by then\r\n        }\r\n      });\r\n      const [getDownloadURL] = await Promise.all([downloadUrl, taskResult]);\r\n      dispatch('FILE_UPLOAD_COMPLETE', name);\r\n      dispatch('FILE_SAVED', name);\r\n      log('saveFile() saved file', {\r\n        storagePath,\r\n        taskResult,\r\n        getDownloadURL,\r\n      });\r\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\r\n    } catch (storageError) {\r\n      if (get(storageError, 'code') === 'storage/unknown') {\r\n        logError(\r\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\r\n          { storageError }\r\n        );\r\n      } else {\r\n        logError('saveFile() error saving file', {\r\n          storageError,\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { joinPaths } from './pathHelper';\r\n\r\nexport function parseStoragePath(\r\n  rawFile: File,\r\n  docPath: string,\r\n  fieldPath: string,\r\n  useFileName: boolean\r\n): string {\r\n  const fileNameBits = rawFile instanceof File ? rawFile.name.split('.') : [];\r\n\r\n  const fileExtension = !fileNameBits?.length ? '' : '.' + fileNameBits.pop();\r\n\r\n  return useFileName\r\n    ? joinPaths(docPath, fieldPath, rawFile.name)\r\n    : joinPaths(docPath, fieldPath + fileExtension);\r\n}\r\n","import { RAFirebaseOptions } from 'index';\r\nimport { IFirebaseWrapper, ResourceManager } from 'providers/database';\r\n\r\nexport async function AddCreatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | 'associateUsersById'\r\n    | 'disableMeta'\r\n    | 'renameMetaFields'\r\n    | 'metaFieldCasing'\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const createAtSelector = GetSelectorsCreateAt(options);\r\n  const createBySelector = GetSelectorsCreateBy(options);\r\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[createBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport async function AddUpdatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | 'associateUsersById'\r\n    | 'disableMeta'\r\n    | 'renameMetaFields'\r\n    | 'metaFieldCasing'\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const updateAtSelector = GetSelectorsUpdateAt(options);\r\n  const updateBySelector = GetSelectorsUpdateBy(options);\r\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[updateBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport function GetSelectorsUpdateAt(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\r\n    return options.renameMetaFields.updated_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'lastupdate';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'lastUpdate';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'last_update';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'LastUpdate';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'last-update';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsUpdateBy(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\r\n    return options.renameMetaFields.updated_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'updatedby';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'updatedBy';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'updated_by';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'UpdatedBy';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'updated-by';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateAt(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\r\n    return options.renameMetaFields.created_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'createdate';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'createDate';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'create_date';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'CreateDate';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'create-date';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateBy(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\r\n    return options.renameMetaFields.created_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'createdby';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'createdBy';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'created_by';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'CreatedBy';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'created-by';\r\n  }\r\n  return defautCase;\r\n}\r\n","import { FirebaseApp } from 'firebase/app';\r\nimport { Auth, User, UserCredential } from 'firebase/auth';\r\nimport {\r\n  CollectionReference,\r\n  DocumentData,\r\n  DocumentReference,\r\n  DocumentSnapshot,\r\n  FieldValue,\r\n  Firestore,\r\n  OrderByDirection,\r\n  Query,\r\n  QueryDocumentSnapshot,\r\n  WriteBatch,\r\n} from 'firebase/firestore';\r\nimport {\r\n  FirebaseStorage,\r\n  StorageReference,\r\n  TaskState,\r\n  UploadTask,\r\n  UploadTaskSnapshot,\r\n} from 'firebase/storage';\r\n\r\nexport type FireUser = User;\r\nexport type FireApp = FirebaseApp;\r\n\r\nexport type FireStorage = FirebaseStorage;\r\nexport type FireStorageReference = StorageReference;\r\nexport type FireUploadTaskSnapshot = UploadTaskSnapshot;\r\nexport type FireUploadTask = UploadTask;\r\nexport type FireStoragePutFileResult = {\r\n  task: FireUploadTask;\r\n  taskResult: Promise<FireUploadTaskSnapshot>;\r\n  downloadUrl: Promise<string>;\r\n};\r\n\r\nexport type FireAuth = Auth;\r\nexport type FireAuthUserCredentials = UserCredential;\r\n\r\nexport type FireStore = Firestore;\r\nexport type FireStoreBatch = WriteBatch;\r\nexport type FireStoreTimeStamp = FieldValue;\r\nexport type FireStoreDocumentRef = DocumentReference;\r\nexport type FireStoreDocumentSnapshot = DocumentSnapshot<DocumentData>;\r\nexport type FireStoreCollectionRef = CollectionReference;\r\nexport type FireStoreQueryDocumentSnapshot = QueryDocumentSnapshot;\r\nexport type FireStoreQuery = Query;\r\nexport type FireStoreQueryOrder = OrderByDirection;\r\n\r\nexport const TASK_PAUSED = 'paused' as TaskState;\r\nexport const TASK_RUNNING = 'running' as TaskState;\r\nexport const TASK_CANCELED = 'cancelled' as TaskState;\r\n","import { Buffer } from 'buffer';\r\nimport {\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  limit,\r\n  query,\r\n  QueryConstraint,\r\n  startAfter,\r\n  startAt,\r\n} from 'firebase/firestore';\r\nimport { ref } from 'firebase/storage';\r\nimport {\r\n  FireStoreCollectionRef,\r\n  FireStoreDocumentSnapshot,\r\n  FireStoreQuery,\r\n} from 'misc/firebase-models';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\n\r\nexport function setQueryCursor(\r\n  document: FireStoreDocumentSnapshot,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string\r\n) {\r\n  const key = Buffer.from(JSON.stringify({ ...params, resourceName })).toString('base64');\r\n  localStorage.setItem(key, document.id);\r\n\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (!localCursorKeys) {\r\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\r\n  } else {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    const newCursors = cursors.concat(key);\r\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\r\n  }\r\n}\r\n\r\nexport async function getQueryCursor(\r\n  collection: FireStoreCollectionRef,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<FireStoreDocumentSnapshot | false> {\r\n  const key = Buffer.from(JSON.stringify({ ...params, resourceName }), 'base64').toString();\r\n  const docId = localStorage.getItem(key);\r\n  if (!docId) {\r\n    return false;\r\n  }\r\n\r\n  const docSnapshot = await getDoc(doc(collection, docId));\r\n  flogger.logDocument(1)();\r\n  if (docSnapshot.exists()) {\r\n    return docSnapshot;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function clearQueryCursors(resourceName: string) {\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (localCursorKeys) {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\r\n    localStorage.removeItem(allCursorsKey);\r\n  }\r\n}\r\n\r\nexport async function findLastQueryCursor(\r\n  collection: FireStoreCollectionRef,\r\n  queryConstraints: QueryConstraint[],\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n) {\r\n  const { page, perPage } = params.pagination;\r\n\r\n  let lastQueryCursor: FireStoreDocumentSnapshot | false = false;\r\n  let currentPage = page - 1;\r\n\r\n  const currentPageParams = {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n    },\r\n  };\r\n  while (!lastQueryCursor && currentPage > 1) {\r\n    currentPage--;\r\n    currentPageParams.pagination.page = currentPage;\r\n    console.log('getting query cursor currentPage=', currentPage);\r\n    lastQueryCursor = await getQueryCursor(\r\n      collection,\r\n      currentPageParams,\r\n      resourceName,\r\n      flogger\r\n    );\r\n  }\r\n  const pageLimit = (page - currentPage) * perPage;\r\n  const isFirst = currentPage === 1;\r\n\r\n  function getQuery() {\r\n    if (isFirst) {\r\n      return query(collection, ...[...queryConstraints, limit(pageLimit)]);\r\n    } else {\r\n      return query(\r\n        collection,\r\n        ...[...queryConstraints, startAfter(lastQueryCursor), limit(pageLimit)]\r\n      );\r\n    }\r\n  }\r\n\r\n  const newQuery = getQuery();\r\n  const snapshots = await getDocs(newQuery);\r\n  const docsLength = snapshots.docs.length;\r\n  flogger.logDocument(docsLength)();\r\n  const lastDocIndex = docsLength - 1;\r\n  const lastDocRef = snapshots.docs[lastDocIndex];\r\n  return lastDocRef;\r\n}\r\n","import {\r\n  getDocs,\r\n  limit,\r\n  orderBy,\r\n  query,\r\n  QueryConstraint,\r\n  startAfter,\r\n  where,\r\n} from 'firebase/firestore';\r\nimport {\r\n  FireStoreCollectionRef,\r\n  FireStoreQuery,\r\n  FireStoreQueryOrder,\r\n} from 'misc/firebase-models';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\r\n\r\ninterface ParamsToQueryOptions {\r\n  filters?: boolean;\r\n  sort?: boolean;\r\n  pagination?: boolean;\r\n}\r\n\r\ninterface QueryPair {\r\n  noPagination: FireStoreQuery;\r\n  withPagination: FireStoreQuery;\r\n}\r\n\r\nconst defaultParamsToQueryOptions = {\r\n  filters: true,\r\n  sort: true,\r\n  pagination: true,\r\n};\r\n\r\nexport async function paramsToQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(\r\n  collection: FireStoreCollectionRef,\r\n  params: TParams,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger,\r\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\r\n): Promise<QueryPair> {\r\n  const filterConstraints = options.filters\r\n    ? getFiltersConstraints(params.filter)\r\n    : [];\r\n\r\n  const sortConstraints = options.sort ? getSortConstraints(params.sort) : [];\r\n\r\n  const paginationConstraints = options.pagination\r\n    ? await getPaginationConstraints(\r\n        collection,\r\n        [...filterConstraints, ...sortConstraints],\r\n        params,\r\n        resourceName,\r\n        flogger\r\n      )\r\n    : [];\r\n\r\n  return {\r\n    noPagination: query(\r\n      collection,\r\n      ...[...filterConstraints, ...sortConstraints]\r\n    ),\r\n    withPagination: query(\r\n      collection,\r\n      ...[...filterConstraints, ...sortConstraints, ...paginationConstraints]\r\n    ),\r\n  };\r\n}\r\n\r\nexport function getFiltersConstraints(filters: {\r\n  [fieldName: string]: any;\r\n}): QueryConstraint[] {\r\n  return Object.entries(filters).flatMap(([fieldName, fieldValue]) => {\r\n    if (Array.isArray(fieldValue)) {\r\n      return [where(fieldName, 'array-contains-any', fieldValue)];\r\n    } else if (typeof fieldValue === 'object') {\r\n      // if fieldValue is an object, { a: 'value', b: 'value' }\r\n      // then we want to return a query for each key in the object\r\n      return Object.entries(fieldValue).map(([key, value]) => {\r\n        return where(fieldName + '.' + key, '==', value);\r\n      });\r\n    } else if (Object.keys(filters).length === 1 && isNaN(fieldValue) && typeof fieldValue !== 'string') {\r\n      return [\r\n        where(fieldName, '>=', fieldValue),\r\n        where(fieldName, '<', fieldValue + 'z'),\r\n      ];\r\n    } else {\r\n      return [where(fieldName, '==', fieldValue)];\r\n    }\r\n  });\r\n}\r\n\r\nexport function getSortConstraints(sort: {\r\n  field: string;\r\n  order: string;\r\n}): QueryConstraint[] {\r\n  if (sort != null && sort.field !== 'id') {\r\n    const { field, order } = sort;\r\n    const parsedOrder = order.toLocaleLowerCase() as FireStoreQueryOrder;\r\n    return [orderBy(field, parsedOrder)];\r\n  }\r\n  return [];\r\n}\r\n\r\nasync function getPaginationConstraints<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(\r\n  collectionRef: FireStoreCollectionRef,\r\n  queryConstraints: QueryConstraint[],\r\n  params: TParams,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<QueryConstraint[]> {\r\n  const { page, perPage } = params.pagination;\r\n\r\n  if (page === 1) {\r\n    return [limit(perPage)];\r\n  } else {\r\n    let queryCursor = await getQueryCursor(\r\n      collectionRef,\r\n      params,\r\n      resourceName,\r\n      flogger\r\n    );\r\n    if (!queryCursor) {\r\n      queryCursor = await findLastQueryCursor(\r\n        collectionRef,\r\n        queryConstraints,\r\n        params,\r\n        resourceName,\r\n        flogger\r\n      );\r\n    }\r\n    return [startAfter(queryCursor), limit(perPage)];\r\n  }\r\n}\r\n\r\nexport function getFullParamsForQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\r\n  return {\r\n    ...reactAdminParams,\r\n    filter: softdeleteEnabled\r\n      ? {\r\n          deleted: false,\r\n          ...reactAdminParams.filter,\r\n        }\r\n      : reactAdminParams.filter,\r\n  };\r\n}\r\n\r\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\r\n  params: TParams\r\n): TParams {\r\n  return {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n      page: params.pagination.page + 1,\r\n    },\r\n  };\r\n}\r\n","import { getCountFromServer, getDocs } from 'firebase/firestore';\r\nimport {\r\n  log,\r\n  messageTypes,\r\n  parseFireStoreDocument,\r\n  recursivelyMapStorageUrls,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient, IResource, ResourceManager } from '../database';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport {\r\n  getFullParamsForQuery,\r\n  getNextPageParams,\r\n  paramsToQuery,\r\n} from './paramsToQuery';\r\nimport { setQueryCursor } from './queryCursors';\r\n\r\nexport class FirebaseLazyLoadingClient {\r\n  constructor(\r\n    private readonly options: RAFirebaseOptions,\r\n    private readonly rm: ResourceManager,\r\n    private client: FireClient\r\n  ) {}\r\n\r\n  public async apiGetList<T extends ra.Record>(\r\n    resourceName: string,\r\n    reactAdminParams: ra.GetListParams\r\n  ): Promise<ra.GetListResult<T>> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    const params = getFullParamsForQuery(\r\n      reactAdminParams,\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    log('apiGetListLazy', { resourceName, params });\r\n\r\n    const { noPagination, withPagination } = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await getDocs(withPagination);\r\n\r\n    const resultsCount = snapshots.docs.length;\r\n    if (!resultsCount) {\r\n      log('apiGetListLazy', {\r\n        message: 'There are not records for given query',\r\n      });\r\n      return { data: [], total: 0 };\r\n    }\r\n    this.client.flogger.logDocument(resultsCount)();\r\n\r\n    // tslint:disable-next-line\r\n    const data = snapshots.docs.map((d) => parseFireStoreDocument<T>(d));\r\n\r\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\r\n    // After fetching documents save queryCursor for next page\r\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\r\n    // Hardcoded to allow next pages, as we don't have total number of items\r\n\r\n    let total = await getCountFromServer(noPagination);\r\n\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetListLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total: total.data().count,\r\n      };\r\n    }\r\n\r\n    log('apiGetListLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n\r\n    return { data, total: total.data().count };\r\n  }\r\n\r\n  public async apiGetManyReference(\r\n    resourceName: string,\r\n    reactAdminParams: messageTypes.IParamsGetManyReference\r\n  ): Promise<messageTypes.IResponseGetManyReference> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    log('apiGetManyReferenceLazy', {\r\n      resourceName,\r\n      resource: r,\r\n      reactAdminParams,\r\n    });\r\n    const filterWithTarget = {\r\n      ...reactAdminParams.filter,\r\n      [reactAdminParams.target]: reactAdminParams.id,\r\n    };\r\n    const params = getFullParamsForQuery(\r\n      {\r\n        ...reactAdminParams,\r\n        filter: filterWithTarget,\r\n      },\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    const { withPagination } = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await getDocs(withPagination);\r\n    const resultsCount = snapshots.docs.length;\r\n    this.client.flogger.logDocument(resultsCount)();\r\n    const data = snapshots.docs.map(parseFireStoreDocument);\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetManyReferenceLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total: data.length,\r\n      };\r\n    }\r\n\r\n    log('apiGetManyReferenceLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n    return { data, total: data.length };\r\n  }\r\n\r\n  private async tryGetResource(\r\n    resourceName: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n}\r\n","import {\r\n  getAbsolutePath,\r\n  log,\r\n  logError,\r\n  logger,\r\n  MakeFirestoreLogger,\r\n  retrieveStatusCode,\r\n} from '../misc';\r\nimport { FireApp } from '../misc/firebase-models';\r\nimport * as ra from '../misc/react-admin-models';\r\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from './commands';\r\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\r\nimport { FireClient } from './database/FireClient';\r\nimport { RAFirebaseOptions } from './options';\r\nimport { GetList, GetMany, GetManyReference, GetOne } from './queries';\r\n\r\nexport interface IDataProvider extends ra.DataProvider {\r\n  app: FireApp;\r\n}\r\n\r\nexport function DataProvider(\r\n  firebaseConfig: {},\r\n  optionsInput?: RAFirebaseOptions\r\n): IDataProvider {\r\n  const options = optionsInput || {};\r\n  verifyDataProviderArgs(firebaseConfig, options);\r\n\r\n  const flogger = MakeFirestoreLogger(options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\r\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\r\n  log('Creating FirebaseDataProvider', {\r\n    firebaseConfig,\r\n    options,\r\n  });\r\n\r\n  const fireWrapper = new FirebaseWrapper(optionsInput, firebaseConfig);\r\n\r\n  async function run<T>(cb: () => Promise<T>) {\r\n    let res: any;\r\n    try {\r\n      res = await cb();\r\n      return res;\r\n    } catch (error) {\r\n      const errorMsg = ((error as any) || '').toString();\r\n      const code = retrieveStatusCode(errorMsg);\r\n      const errorObj = { status: code, message: errorMsg, json: res };\r\n      logError('DataProvider:', error, { errorMsg, code, errorObj });\r\n      throw errorObj;\r\n    }\r\n  }\r\n  const client = new FireClient(fireWrapper, options, flogger);\r\n\r\n  const newProviderApi: IDataProvider = {\r\n    app: fireWrapper.GetApp(),\r\n    getList<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetListParams\r\n    ): Promise<ra.GetListResult<RecordType>> {\r\n      return run(() => GetList<RecordType>(resource, params, client));\r\n    },\r\n    getOne<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetOneParams\r\n    ): Promise<ra.GetOneResult<RecordType>> {\r\n      return run(() => GetOne<RecordType>(resource, params, client));\r\n    },\r\n    getMany<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyParams\r\n    ): Promise<ra.GetManyResult<RecordType>> {\r\n      return run(() => GetMany<RecordType>(resource, params, client));\r\n    },\r\n    getManyReference<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyReferenceParams\r\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\r\n      return run(() => GetManyReference<RecordType>(resource, params, client));\r\n    },\r\n    update<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.UpdateParams\r\n    ): Promise<ra.UpdateResult<RecordType>> {\r\n      return run(() => Update<RecordType>(resource, params, client));\r\n    },\r\n    updateMany(\r\n      resource: string,\r\n      params: ra.UpdateManyParams\r\n    ): Promise<ra.UpdateManyResult> {\r\n      return run(() => UpdateMany(resource, params, client));\r\n    },\r\n    create<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.CreateParams\r\n    ): Promise<ra.CreateResult<RecordType>> {\r\n      return run(() => Create<RecordType>(resource, params, client));\r\n    },\r\n    delete<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.DeleteParams\r\n    ): Promise<ra.DeleteResult<RecordType>> {\r\n      return run(() => Delete(resource, params, client));\r\n    },\r\n    deleteMany(\r\n      resource: string,\r\n      params: ra.DeleteManyParams\r\n    ): Promise<ra.DeleteManyResult> {\r\n      return run(() => DeleteMany(resource, params, client));\r\n    },\r\n  };\r\n\r\n  return newProviderApi;\r\n}\r\n\r\nfunction verifyDataProviderArgs(\r\n  firebaseConfig: {},\r\n  options?: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n  if (options && options.rootRef) {\r\n    // Will throw error if rootRef doesn't point to a document\r\n    getAbsolutePath(options.rootRef, 'test');\r\n  }\r\n}\r\n","import {\r\n  filterArray,\r\n  log,\r\n  recursivelyMapStorageUrls,\r\n  sortArray,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\r\n\r\nexport async function GetList<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetListParams,\r\n  client: FireClient\r\n): Promise<ra.GetListResult<T>> {\r\n  log('GetList', { resourceName, params });\r\n  const { rm, fireWrapper, options } = client;\r\n\r\n  if (options?.lazyLoading?.enabled) {\r\n    const lazyClient = new FirebaseLazyLoadingClient(options, rm, client);\r\n    return lazyClient.apiGetList<T>(resourceName, params);\r\n  }\r\n\r\n  const filterSafe = params.filter || {};\r\n\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  delete filterSafe.collectionQuery;\r\n\r\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\r\n  const data = r.list;\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === 'ASC') {\r\n      sortArray(data, field, 'asc');\r\n    } else {\r\n      sortArray(data, field, 'desc');\r\n    }\r\n  }\r\n  let softDeleted = data;\r\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\r\n    softDeleted = data.filter((doc) => !doc.deleted);\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\r\n  const total = filteredData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const fetchedData = await Promise.all(\r\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return {\r\n      data: fetchedData,\r\n      total,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: dataPage,\r\n    total,\r\n  };\r\n}\r\n","import { log, translateDocFromFirestore } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetOne<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetOneParams,\r\n  client: FireClient\r\n): Promise<ra.GetOneResult<T>> {\r\n  log('GetOne', { resourceName, params });\r\n  const { rm } = client;\r\n  try {\r\n    const id = params.id + '';\r\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\r\n    client.flogger.logDocument(1)();\r\n    return { data: dataSingle as T };\r\n  } catch (error) {\r\n    throw new Error(\r\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\r\n    );\r\n  }\r\n}\r\n","import { doc, getDoc } from 'firebase/firestore';\r\nimport { log, recursivelyMapStorageUrls } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetMany<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  const ids = params.ids;\r\n  log('GetMany', { resourceName, resource: r, params, ids });\r\n  const matchDocSnaps = await Promise.all(\r\n    ids.map((idObj) => {\r\n      if (typeof idObj === 'string') {\r\n        return getDoc(doc(r.collection, idObj));\r\n      }\r\n      // Will get and resolve reference documents into the current doc\r\n      return getDoc(doc(r.collection, (idObj as any)['___refid']));\r\n    })\r\n  );\r\n  client.flogger.logDocument(ids.length)();\r\n  const matches = matchDocSnaps.map(\r\n    (snap) => ({ ...snap.data(), id: snap.id } as T)\r\n  );\r\n  const permittedData = options.softDelete\r\n    ? matches.filter((row) => !row['deleted'])\r\n    : matches;\r\n  if (options.relativeFilePaths) {\r\n    const data = await Promise.all(\r\n      permittedData.map((d) => recursivelyMapStorageUrls(fireWrapper, d))\r\n    );\r\n    return {\r\n      data,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: permittedData,\r\n  };\r\n}\r\n","import {\r\n  filterArray,\r\n  log,\r\n  recursivelyMapStorageUrls,\r\n  sortArray,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetManyReference<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyReferenceParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyReferenceResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  log('GetManyReference', { resourceName, params });\r\n  const filterSafe = params.filter || {};\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\r\n  delete filterSafe.collectionQuery;\r\n  log('apiGetManyReference', { resourceName, resource: r, params });\r\n  const data = r.list;\r\n  const targetField = params.target;\r\n  const targetValue = params.id;\r\n  let softDeleted = data;\r\n  if (options.softDelete) {\r\n    softDeleted = data.filter((doc) => !doc['deleted']);\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const targetIdFilter: Record<string, ra.Identifier> = {};\r\n  targetIdFilter[targetField] = targetValue;\r\n  const permittedData = filterArray(filteredData, targetIdFilter);\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === 'ASC') {\r\n      sortArray(permittedData, field, 'asc');\r\n    } else {\r\n      sortArray(permittedData, field, 'desc');\r\n    }\r\n  }\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\r\n  const total = permittedData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const fetchedData = await Promise.all(\r\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return { data: fetchedData, total };\r\n  }\r\n\r\n  return { data: dataPage, total };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function Update<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.UpdateParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateResult<T>> {\r\n  const { rm } = client;\r\n  log('Update', { resourceName, params });\r\n  const id = params.id + '';\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('Update', { resourceName, resource: r, params });\r\n  const data = await client.parseDataAndUpload(r, id, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, id);\r\n  await client.addUpdatedByFields(docObj);\r\n  const docObjTransformed = client.transformToDb(resourceName, docObj, id);\r\n  await updateDoc(doc(r.collection, id), docObjTransformed);\r\n  return {\r\n    data: {\r\n      ...data,\r\n      id: id,\r\n    },\r\n  };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function UpdateMany(\r\n  resourceName: string,\r\n  params: ra.UpdateManyParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateManyResult> {\r\n  const { rm } = client;\r\n  log('UpdateMany', { resourceName, params });\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('UpdateMany', { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async (id) => {\r\n      const idStr = id + '';\r\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\r\n      const docObj = { ...data };\r\n      client.checkRemoveIdField(docObj, idStr);\r\n      await client.addUpdatedByFields(docObj);\r\n      const docObjTransformed = client.transformToDb(\r\n        resourceName,\r\n        docObj,\r\n        idStr\r\n      );\r\n      await updateDoc(doc(r.collection, idStr), docObjTransformed);\r\n      return {\r\n        ...data,\r\n        id: idStr,\r\n      };\r\n    })\r\n  );\r\n  return {\r\n    data: returnData,\r\n  };\r\n}\r\n","import { doc, getDoc, setDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function Create<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.CreateParams,\r\n  client: FireClient\r\n): Promise<ra.CreateResult<T>> {\r\n  const { rm, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('Create', { resourceName, resource: r, params });\r\n  const hasOverridenDocId = params.data && params.data.id;\r\n  log('Create', { hasOverridenDocId });\r\n  if (hasOverridenDocId) {\r\n    const overridenId = params.data.id;\r\n    const exists = (await getDoc(doc(r.collection, overridenId))).exists();\r\n    if (exists) {\r\n      throw new Error(\r\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\r\n      );\r\n    }\r\n\r\n    const createData = await client.parseDataAndUpload(\r\n      r,\r\n      overridenId,\r\n      params.data\r\n    );\r\n    if (!overridenId) {\r\n      throw new Error('id must be a valid string');\r\n    }\r\n    const createDocObj = { ...createData };\r\n    client.checkRemoveIdField(createDocObj, overridenId);\r\n    await client.addCreatedByFields(createDocObj);\r\n    await client.addUpdatedByFields(createDocObj);\r\n    const createDocObjTransformed = client.transformToDb(\r\n      resourceName,\r\n      createDocObj,\r\n      overridenId\r\n    );\r\n    log('Create', { docObj: createDocObj });\r\n    await setDoc(doc(r.collection, overridenId), createDocObjTransformed, {\r\n      merge: false,\r\n    });\r\n    return {\r\n      data: {\r\n        ...createDocObjTransformed,\r\n        id: overridenId,\r\n      },\r\n    };\r\n  }\r\n  const newId = fireWrapper.dbMakeNewId();\r\n  const data = await client.parseDataAndUpload(r, newId, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, newId);\r\n  await client.addCreatedByFields(docObj);\r\n  await client.addUpdatedByFields(docObj);\r\n  const docObjTransformed = client.transformToDb(resourceName, docObj, newId);\r\n  await setDoc(doc(r.collection, newId), docObjTransformed, { merge: false });\r\n  return {\r\n    data: {\r\n      ...docObjTransformed,\r\n      id: newId,\r\n    },\r\n  };\r\n}\r\n","import { deleteDoc, doc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\nimport { DeleteSoft } from './Delete.Soft';\r\n\r\nexport async function Delete<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm, options } = client;\r\n  if (options.softDelete) {\r\n    return DeleteSoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('apiDelete', { resourceName, resource: r, params });\r\n  try {\r\n    const id = params.id + '';\r\n\r\n    await deleteDoc(doc(r.collection, id));\r\n  } catch (error) {\r\n    throw new Error(error as any);\r\n  }\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log, logError } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function DeleteSoft<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm } = client;\r\n  const id = params.id + '';\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteSoft', { resourceName, resource: r, params });\r\n  const docObj = { deleted: true };\r\n  await client.addUpdatedByFields(docObj);\r\n\r\n  updateDoc(doc(r.collection, id), docObj).catch((error) => {\r\n    logError('DeleteSoft error', { error });\r\n  });\r\n\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { doc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\nimport { DeleteManySoft } from './DeleteMany.Soft';\r\n\r\nexport async function DeleteMany(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { options, rm, fireWrapper } = client;\r\n  if (options.softDelete) {\r\n    return DeleteManySoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteMany', { resourceName, resource: r, params });\r\n  const returnData: ra.Identifier[] = [];\r\n  const batch = fireWrapper.dbCreateBatch();\r\n  for (const id of params.ids) {\r\n    const idStr = id + '';\r\n    const docToDelete = doc(r.collection, idStr);\r\n    batch.delete(docToDelete);\r\n    returnData.push(id);\r\n  }\r\n\r\n  try {\r\n    await batch.commit();\r\n  } catch (error) {\r\n    throw new Error(error as any);\r\n  }\r\n  return { data: returnData };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log, logError } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function DeleteManySoft(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { rm } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteManySoft', { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async (id) => {\r\n      const idStr = id + '';\r\n      const docObj = { deleted: true };\r\n      await client.addUpdatedByFields(docObj);\r\n      updateDoc(doc(r.collection, idStr), docObj).catch((error) => {\r\n        logError('apiSoftDeleteMany error', { error });\r\n      });\r\n      return idStr;\r\n    })\r\n  );\r\n  return {\r\n    data: returnData,\r\n  };\r\n}\r\n"],"names":["sortArray","data","field","dir","sort","a","b","rawA","get","rawB","isAsc","Number","isFinite","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","value","searchField","searchValue","tree","leaves","recursivelyWalk","obj","path","key","hasOwnProperty","objVal","currentPath","Array","push","objectFlatten","getFieldReferences","filter","row","reduce","acc","cur","res","searchThis","toString","includes","isArray","doesRowMatch","LogNoOp","args","LoggerBase","title","cacheEnabledKey","constructor","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","log","console","bind","warn","error","logger","KEY_SINGLE","logError","logWarn","dispatch","eventName","fileName","eventMonitor","document","getElementById","event","CustomEvent","detail","dispatchEvent","REF_INDENTIFIER","translateDocFromFirestore","result","parsedDoc","refdocs","recusivelyCheckObjectValue","input","fieldPath","toDate","index","isInputADocReference","documentReference","refDocPath","id","firestore","parent","recursivelyMapStorageUrls","async","fireWrapper","fieldValue","has","src","getDownloadURL","ref","storage","Promise","all","parseFireStoreDocument","doc","dataWithRefs","refDocs","d","set","applyRefDocs","getAbsolutePath","rootRef","relativePath","Error","rootRefValue","withSlashes","join","split","length","slice","joinPaths","translateDocToFirestore","uploads","recusivelyParseObjectValue","fieldDotsPath","refPath","fieldSlashesPath","rawFile","FirebaseWrapper","_app","_firestore","_storage","_auth","options","inputOptions","firebaseConfig","optionsSafe","window","app","getApps","getApp","initializeApp","ObtainFirebaseApp","getFirestore","getStorage","getAuth","dbGetCollection","absolutePath","collection","dbCreateBatch","writeBatch","dbMakeNewId","OnUserLogout","callBack","onAuthStateChanged","user","isLoggedOut","putFile","storagePath","task","uploadBytesResumable","taskResult","rej","then","catch","downloadUrl","t","url","fieldSrc","serverTimestamp","firestoreServerTimestamp","persistenceInput","persistenceResolved","browserLocalPersistence","inMemoryPersistence","browserSessionPersistence","setPersistence","email","password","signInWithEmailAndPassword","signOut","resolve","reject","auth","currentUser","unsubscribe","authGetUserLoggedIn","GetApp","db","AuthClient","optionsInput","persistence","authSetPersistence","params","username","getUserLogin","authSigninEmailPassword","e","HandleAuthLogout","authSignOut","HandleAuthError","errorHttp","status","retrieveStatusTxt","getIdTokenResult","claims","uid","displayName","photoURL","fullName","avatar","authTime","expirationTime","signInProvider","issuedAtTime","token","ResourceManager","flogger","resources","resourceName","refresh","collectionQuery","RefreshResource","TryGetResourcePromise","GetResource","resource","initPath","lazyLoading","enabled","collectionRef","collectionOrQuery","applyQuery","newDocs","getDocs","list","forEach","logDocument","docs","collectionPath","docId","docSnap","getDoc","exists","hasBeenInited","pathAbsolute","allResources","associateUsersById","getCurrentUserId","getCurrentUserEmail","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","transformToDb","documentData","r","docPath","u","useFileName","fileNameBits","File","name","fileExtension","pop","parseStoragePath","useFileNamesInStorage","link","saveFile","disableMeta","currentUserIdentifier","getUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","defautCase","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","updateAtSelector","updated_at","GetSelectorsUpdateAt","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","on","snapshot","progress","bytesTransferred","totalBytes","state","relativeFilePaths","storageError","getQueryCursor","Buffer","from","JSON","stringify","docSnapshot","defaultParamsToQueryOptions","filters","pagination","paramsToQuery","filterConstraints","entries","flatMap","where","isNaN","sortConstraints","order","parsedOrder","toLocaleLowerCase","orderBy","getSortConstraints","paginationConstraints","queryConstraints","page","perPage","limit","queryCursor","lastQueryCursor","currentPage","currentPageParams","pageLimit","newQuery","query","startAfter","snapshots","docsLength","findLastQueryCursor","getPaginationConstraints","noPagination","withPagination","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","FirebaseLazyLoadingClient","client","tryGetResource","softDelete","resultsCount","message","total","allCursorsKey","localCursorKeys","newCursors","parse","concat","setQueryCursor","getNextPageParams","getCountFromServer","parsedData","count","filterWithTarget","target","VerifyAuthProviderArgs","logging","login","HandleAuthLogin","logout","checkAuth","HandleAuthCheck","checkError","getPermissions","HandleGetPermissions","getIdentity","HandleGetIdentity","getAuthUser","getJWTAuthTime","HandleGetJWTAuthTime","getJWTExpirationTime","HandleGetJWTExpirationTime","getJWTSignInProvider","HandleGetJWTSignInProvider","getJWTClaims","getJWTToken","HandleGetJWTToken","verifyDataProviderArgs","ResetCount","shouldReset","docCount","incrementBy","currentCountRaw","incremented","parseInt","incrementRead","MakeFirestoreLogger","firestoreCostsLogger","persistCount","run","cb","errorMsg","code","statusTxt","regexResult","exec","retrieveStatusCode","errorObj","json","getList","apiGetList","filterSafe","TryGetResource","softDeleted","filteredData","pageStart","dataPage","GetList","getOne","dataSingle","GetSingleDoc","GetOne","getMany","ids","matchDocSnaps","idObj","matches","snap","permittedData","GetMany","getManyReference","targetField","targetValue","targetIdFilter","GetManyReference","update","parseDataAndUpload","docObj","addUpdatedByFields","docObjTransformed","updateDoc","Update","updateMany","idStr","UpdateMany","create","hasOverridenDocId","overridenId","createData","createDocObj","addCreatedByFields","createDocObjTransformed","setDoc","merge","newId","Create","delete","previousData","DeleteSoft","deleteDoc","Delete","deleteMany","DeleteManySoft","returnData","batch","docToDelete","commit","DeleteMany"],"mappings":"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"}